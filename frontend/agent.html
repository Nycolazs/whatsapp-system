<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- N√£o for√ßar downgrade para HTTP: √°udio (microfone) exige contexto seguro (HTTPS) fora do localhost. -->
  <script src="/ui.js"></script>
  <title>Atendimento - WhatsApp System</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f0f2f5;
      height: 100vh;
      overflow: hidden;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    /* Lista de Tickets */
    .tickets-panel {
      width: 350px;
      background: white;
      border-right: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      padding: 20px;
      background: #00a884;
      color: white;
    }

    .panel-header h2 {
      font-size: 18px;
      margin-bottom: 5px;
    }

    .panel-header .user-section {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.3);
    }

    .panel-header .admin-actions {
      margin-top: 10px;
    }

    .btn-manage-sellers {
      width: 100%;
      padding: 8px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s;
    }

    .btn-manage-sellers:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .logout-btn {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: background 0.2s;
    }

    .logout-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .tickets-list {
      flex: 1;
      overflow-y: auto;
    }

    .tickets-filters {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 16px;
      border-bottom: 1px solid #e0e0e0;
      background: #f7f9fb;
      font-size: 12px;
      color: #667781;
      gap: 10px;
    }

    .tickets-filters label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    .ticket-item {
      padding: 15px 20px;
      border-bottom: 1px solid #e0e0e0;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .ticket-item:hover {
      background: #f5f5f5;
    }

    .ticket-item.active {
      background: #e9f7f3;
    }

    .ticket-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: #dfe5e7;
      flex-shrink: 0;
      object-fit: cover;
    }

    .ticket-default-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: #dfe5e7;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #667781;
      font-size: 20px;
      font-weight: 600;
    }

    .ticket-content {
      flex: 1;
      min-width: 0;
    }

    .ticket-phone {
      font-weight: 600;
      margin-bottom: 5px;
      color: #111;
    }

    .ticket-preview {
      font-size: 13px;
      color: #667781;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .ticket-seller-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: #00a884;
      background: rgba(0, 168, 132, 0.1);
      padding: 3px 8px;
      border-radius: 10px;
      font-weight: 600;
      margin-top: 4px;
    }

    .ticket-unassigned-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: #ff9800;
      background: rgba(255, 152, 0, 0.1);
      padding: 3px 8px;
      border-radius: 10px;
      font-weight: 600;
      margin-top: 4px;
    }

    .ticket-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 5px;
      font-size: 11px;
      color: #667781;
    }

    .ticket-status {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
    }

    .status-pendente {
      background: #fff3cd;
      color: #856404;
    }

    .status-aguardando {
      background: #fff0e0;
      color: #7a4b00;
    }

    .status-em_atendimento {
      background: #d1ecf1;
      color: #0c5460;
    }

    .status-resolvido {
      background: #d4edda;
      color: #155724;
    }
    .status-encerrado {
      background: #d4edda;
      color: #155724;
    }

    /* Chat Panel */
    .chat-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #efeae2;
      min-height: 0; /* Importante para flex com overflow */
    }

    .chat-header {
      padding: 15px 20px;
      background: #f0f2f5;
      border-bottom: 1px solid #d1d7db;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .chat-info {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .chat-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #dfe5e7;
      object-fit: cover;
    }

    .chat-default-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #dfe5e7;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #667781;
      font-size: 16px;
      font-weight: 600;
    }

    .chat-text h3 {
      font-size: 16px;
      color: #111;
    }

    .chat-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 600;
      background: #e8eef5;
      color: #2b3a55;
      border: 1px solid #d1d7db;
    }

    .status-pill.status-pendente {
      background: #fff3cd;
      color: #856404;
      border-color: #f1e3a5;
    }

    .status-pill.status-aguardando {
      background: #fff0e0;
      color: #7a4b00;
      border-color: #f7d1a6;
    }

    .status-pill.status-em_atendimento {
      background: #d1ecf1;
      color: #0c5460;
      border-color: #b8e2e8;
    }

    .status-pill.status-resolvido,
    .status-pill.status-encerrado {
      background: #d4edda;
      color: #155724;
      border-color: #bfe3c6;
    }

    .chat-reminders {
      background: #f8fafc;
      border-bottom: 1px solid #e2e8f0;
      padding: 10px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .reminders-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .reminders-title {
      font-size: 13px;
      font-weight: 600;
      color: #0f172a;
    }

    .reminder-btn {
      background: #00a884;
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
    }

    .reminder-btn.secondary {
      background: #e2e8f0;
      color: #111;
    }

    .close-chat-btn {
      background: #f1f5f9;
      color: #0f172a;
      border: 1px solid #e2e8f0;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
    }

    .reminder-form {
      display: none;
      grid-template-columns: 1fr;
      gap: 8px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 10px;
    }

    .reminder-form.active {
      display: grid;
    }

    .reminder-form input,
    .reminder-form textarea {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #d1d7db;
      font-size: 13px;
      font-family: inherit;
    }

    .reminder-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .reminder-modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.45);
      z-index: 1400;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }

    .reminder-modal.active {
      display: flex;
      animation: fadeIn 0.16s ease;
    }

    .reminder-modal-card {
      width: min(94vw, 560px);
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25);
      padding: 16px 18px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      animation: popIn 0.18s ease;
      overflow: visible;
      position: relative;
    }

    .reminder-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .reminder-modal-title {
      font-size: 16px;
      font-weight: 600;
      color: #0f172a;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .reminder-modal-subtitle {
      font-size: 12px;
      color: #64748b;
      margin-top: 2px;
    }

    .reminder-modal-close {
      border: none;
      background: #f1f5f9;
      color: #0f172a;
      width: 32px;
      height: 32px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.15s ease, background 0.2s ease;
    }

    .reminder-modal-close:hover {
      background: #e2e8f0;
      transform: rotate(4deg);
    }

    .reminder-modal-body {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      overflow: visible;
    }

    .reminder-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      color: #475569;
      font-weight: 600;
      position: relative;
    }

    .reminder-field > span::before {
      display: inline-block;
      margin-right: 6px;
      opacity: 0.8;
    }

    .reminder-field[data-icon="calendar"] > span::before {
      content: "üìÖ";
    }

    .reminder-field[data-icon="clock"] > span::before {
      content: "üïí";
    }

    .reminder-field[data-icon="note"] > span::before {
      content: "üìù";
    }

    .reminder-field.full {
      grid-column: 1 / -1;
    }

    .reminder-list-section {
      grid-column: 1 / -1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
      padding-top: 6px;
      border-top: 1px dashed #e2e8f0;
    }

    .reminder-list-title {
      font-size: 12px;
      font-weight: 600;
      color: #0f172a;
    }

    .reminder-field input,
    .reminder-field textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #d1d7db;
      border-radius: 10px;
      font-size: 13px;
      font-family: inherit;
      background: #f8fafc;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .reminder-picker-trigger {
      width: 100%;
      background: #f8fafc;
      border: 1px solid #d1d7db;
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
      font-family: inherit;
      color: #0f172a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      cursor: pointer;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .reminder-picker-trigger .time-trigger-label {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    .clock-icon {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffffff 0 40%, #e2e8f0 41% 100%);
      border: 1px solid #cbd5f5;
      position: relative;
      flex-shrink: 0;
      box-shadow: inset 0 0 0 2px #ffffff, 0 2px 6px rgba(15, 23, 42, 0.12);
    }

    .clock-icon::before,
    .clock-icon::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: left center;
      border-radius: 2px;
    }

    .clock-icon::before {
      width: 2px;
      height: 6px;
      background: #2563eb;
      transform: translate(-50%, -80%);
    }

    .clock-icon::after {
      width: 6px;
      height: 2px;
      background: #0f172a;
      transform: translate(-10%, -50%);
    }

    .clock-picker-header {
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .clock-picker-title {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .clock-picker-title .clock-icon {
      width: 20px;
      height: 20px;
      box-shadow: inset 0 0 0 2px #ffffff, 0 3px 8px rgba(15, 23, 42, 0.14);
    }

    .clock-time-display {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 18px;
      font-weight: 700;
      color: #0f172a;
    }

    .clock-time-part {
      border: 1px solid #c7d2fe;
      background: #eef2ff;
      border-radius: 10px;
      padding: 4px 10px;
      font-family: inherit;
      font-size: 18px;
      font-weight: 700;
      color: #1e293b;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .clock-time-part.active {
      background: #2563eb;
      border-color: #2563eb;
      color: #fff;
      box-shadow: 0 8px 18px rgba(37, 99, 235, 0.25);
    }

    .clock-time-part:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.28);
    }

    .clock-time-sep {
      font-size: 18px;
      font-weight: 700;
      color: #475569;
    }

    .clock-step-hint {
      font-size: 12px;
      color: #64748b;
    }

    .reminder-picker-trigger:hover {
      border-color: #94a3b8;
    }

    .reminder-picker-trigger:focus {
      outline: none;
      border-color: #60a5fa;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2);
    }

    .picker-caret {
      color: #64748b;
      font-size: 12px;
    }

    .reminder-picker {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      right: 0;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      box-shadow: 0 14px 34px rgba(15, 23, 42, 0.15);
      padding: 10px;
      z-index: 1500;
      display: none;
    }

    .reminder-picker.active {
      display: block;
      animation: fadeIn 0.16s ease;
    }

    .picker-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }

    .picker-month {
      font-size: 12px;
      font-weight: 600;
      color: #0f172a;
      text-align: center;
      flex: 1;
    }

    .picker-nav {
      background: #f1f5f9;
      border: none;
      border-radius: 8px;
      width: 28px;
      height: 28px;
      cursor: pointer;
      color: #0f172a;
      font-size: 16px;
    }

    .picker-weekdays {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      font-size: 10px;
      color: #64748b;
      text-align: center;
      margin-bottom: 6px;
    }

    .picker-days {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
    }

    .picker-day {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: none;
      border-radius: 8px;
      background: transparent;
      cursor: pointer;
      font-size: 12px;
      color: #0f172a;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .picker-day:hover {
      background: #e2e8f0;
    }

    .picker-day.selected {
      background: #2563eb;
      color: #fff;
      font-weight: 600;
    }

    .picker-day.muted {
      color: #cbd5f5;
      cursor: default;
    }

    .clock-picker-body {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .clock-face {
      width: min(520px, 100%);
      aspect-ratio: 1 / 1;
      border-radius: 50%;
      position: relative;
      background: radial-gradient(circle at 30% 30%, #ffffff 0%, #f1f5f9 58%, #e2e8f0 100%);
      border: 1px solid #e2e8f0;
      box-shadow: inset 0 0 0 6px rgba(255, 255, 255, 0.7), 0 12px 24px rgba(15, 23, 42, 0.12);
      display: flex;
      align-items: center;
      justify-content: center;
      outline: none;
    }

    .clock-markers {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .clock-markers .clock-marker {
      pointer-events: auto;
    }

    .clock-hand {
      position: absolute;
      width: 3px;
      height: 40%;
      background: #2563eb;
      top: 10%;
      left: 50%;
      transform-origin: bottom center;
      transform: translateX(-50%) rotate(0deg);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.35);
    }

    .clock-center {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #2563eb;
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.15);
    }

    .clock-marker {
      position: absolute;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid transparent;
      color: #0f172a;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transform: translate(-50%, -50%);
      transition: all 0.18s ease;
    }

    .clock-marker.dot {
      width: 12px;
      height: 12px;
      font-size: 10px;
      color: #94a3b8;
    }

    .clock-marker:hover {
      border-color: #94a3b8;
      background: #e2e8f0;
    }

    .clock-marker.selected {
      background: #2563eb;
      color: #ffffff;
      border-color: #2563eb;
      box-shadow: 0 10px 18px rgba(37, 99, 235, 0.28);
    }

    .clock-marker:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.3);
      border-color: #60a5fa;
    }

    .clock-footer {
      display: flex;
      width: 100%;
      justify-content: space-between;
      gap: 10px;
    }

    .clock-action {
      flex: 1;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 8px 10px;
      background: #f8fafc;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .clock-action.primary {
      background: #2563eb;
      color: #fff;
      border-color: #2563eb;
    }

    .clock-action:hover {
      border-color: #94a3b8;
    }

    @media (max-width: 480px) {
      .clock-face {
        width: min(380px, 100%);
      }

      .clock-time-display {
        font-size: 16px;
      }
    }

    .reminder-field input:focus,
    .reminder-field textarea:focus {
      border-color: #60a5fa;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2);
    }

    .reminder-modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes popIn {
      from { transform: scale(0.98) translateY(6px); opacity: 0.6; }
      to { transform: scale(1) translateY(0); opacity: 1; }
    }

    .reminders-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .reminder-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px 10px;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      background: #ffffff;
    }

    .reminder-item .reminder-date {
      font-size: 12px;
      font-weight: 600;
      color: #0f172a;
    }

    .reminder-item .reminder-note {
      font-size: 12px;
      color: #4b5563;
      word-break: break-word;
    }

    .reminder-item .reminder-actions {
      justify-content: flex-start;
    }

    .chat-actions select {
      display: none;
    }

    /* Custom Select */
    .custom-select {
      position: relative;
      display: inline-block;
      min-width: 150px;
    }

    .custom-select-trigger {
      padding: 8px 30px 8px 12px;
      background: white;
      border: 1px solid #d1d7db;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s;
      position: relative;
      color: #111;
    }

    .custom-select-trigger:hover {
      border-color: #00a884;
      box-shadow: 0 2px 4px rgba(0, 168, 132, 0.1);
    }

    .custom-select-trigger::after {
      content: '‚ñº';
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 10px;
      color: #667781;
      transition: transform 0.2s;
    }

    .custom-select.open .custom-select-trigger::after {
      transform: translateY(-50%) rotate(180deg);
    }

    .custom-select-options {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #d1d7db;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: none;
      z-index: 1000;
      max-height: 200px;
      overflow-y: auto;
    }

    .custom-select.open .custom-select-options {
      display: block;
      animation: slideDown 0.2s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .custom-select-option {
      padding: 10px 12px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 13px;
      color: #111;
    }

    .custom-select-option:hover {
      background: #f0f2f5;
    }

    .custom-select-option.selected {
      background: #e7f5f2;
      color: #00a884;
      font-weight: 500;
    }

    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      min-height: 0; /* Importante para permitir scroll */
    }

    .message {
      max-width: 65%;
      padding: 8px 12px;
      border-radius: 8px;
      word-wrap: break-word;
    }

    .message-client {
      background: white;
      align-self: flex-start;
      margin-right: auto;
    }

    .message-agent {
      background: #d9fdd3;
      align-self: flex-end;
      margin-left: auto;
    }

    .message-system {
      background: rgba(17, 24, 39, 0.06);
      border: 1px solid rgba(17, 24, 39, 0.10);
      color: #111827;
      align-self: center;
      margin-left: auto;
      margin-right: auto;
      max-width: 90%;
      text-align: center;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
    }

    .message-system .message-time {
      text-align: center;
    }

    .message-time {
      font-size: 11px;
      color: #667781;
      margin-top: 4px;
      text-align: right;
    }

    .message-image {
      max-width: 260px;
      border-radius: 8px;
      margin-top: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      opacity: 0;
      display: block;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    .message-image.loaded {
      opacity: 1;
    }

    .message-image:hover {
      opacity: 0.9;
      transform: scale(0.98);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .message-image:active {
      transform: scale(0.95);
    }

    .message-sticker {
      max-width: 200px;
      max-height: 200px;
      margin-top: 8px;
      margin-bottom: 8px;
      display: block;
      opacity: 0;
      transition: all 0.2s ease;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    .message-sticker.loaded {
      opacity: 1;
    }

    .message-sticker:hover {
      transform: scale(0.98);
    }

    .message-sticker:active {
      transform: scale(0.95);
    }

    /* Estilo para v√≠deos */
    .message video {
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .message video:hover {
      opacity: 0.9;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    /* Estilo para bot√£o de √°udio */
    .audio-play-btn {
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      -webkit-user-select: none;
    }

    .audio-play-btn:hover {
      transform: scale(1.1);
    }

    .audio-play-btn:active {
      transform: scale(0.95);
    }

    .image-loading {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
      color: #667781;
      font-size: 13px;
      font-style: italic;
    }

    .image-loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #e0e0e0;
      border-top: 2px solid #00a884;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Lightbox para imagens */
    .image-lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .image-lightbox.active {
      display: flex;
    }

    .image-lightbox img {
      max-width: 90%;
      max-height: 90vh;
      border-radius: 8px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .reply-preview {
      display: none;
      background: #f0f2f5;
      padding: 8px 20px 6px 20px;
      border: none;
      margin: 0;
      font-size: 13px;
    }

    .reply-preview.active {
      display: block;
    }

    .reply-preview-header {
      font-weight: 600;
      color: #00a884;
      margin-bottom: 2px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .reply-preview-content {
      color: #65676b;
      margin-bottom: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
    }

    .reply-preview-close {
      background: none;
      border: none;
      color: #65676b;
      cursor: pointer;
      font-size: 16px;
      padding: 0;
      font-weight: bold;
    }

    .reply-preview-close:hover {
      color: #333;
    }

    .message-quote {
      background: #f0f2f5;
      padding: 10px 12px;
      border-left: 4px solid #00a884;
      border-radius: 4px;
      margin: 8px 0;
      font-size: 12px;
    }

    .message-quote-author {
      font-weight: 600;
      color: #00a884;
      margin-bottom: 4px;
    }

    .message-quote-content {
      color: #65676b;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .message-input-area {
      padding: 15px 20px;
      background: #f0f2f5;
      display: flex;
      gap: 10px;
      align-items: flex-end;
      border-top: 1px solid #d1d7db;
      flex-shrink: 0; /* Impede que encolha */
    }

    .ticket-history {
      margin-top: 6px;
      font-size: 12px;
      color: #667781;
      display: none;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .ticket-history a {
      color: #00a884;
      text-decoration: none;
      cursor: pointer;
    }

    .ticket-history a:hover {
      text-decoration: underline;
    }

    .history-status {
      display: inline-flex;
      align-items: center;
      padding: 1px 6px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 600;
      margin-left: 6px;
    }

    .message-input {
      flex: 1;
      padding: 12px 15px;
      border: 1px solid #d1d7db;
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      resize: none;
      max-height: 120px;
      min-height: 44px;
    }

    .send-button {
      padding: 12px 25px;
      background: #00a884;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: background 0.2s;
    }

    .send-button:hover {
      background: #008f6c;
    }

    .send-button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .audio-button {
      padding: 12px 20px;
      background: #f0f2f5;
      color: #00a884;
      border: 2px solid #00a884;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
    }

    .audio-button:hover {
      background: #e8f5f2;
    }

    .audio-button:disabled {
      background: #ccc;
      color: #999;
      border-color: #999;
      cursor: not-allowed;
    }

    .audio-button.recording {
      background: #ff6b6b;
      color: white;
      border-color: #ff6b6b;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .recording-modal {
      display: none;
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      border-radius: 50px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
      padding: 12px 24px;
      z-index: 1000;
      min-width: 180px;
      text-align: center;
    }

    .recording-modal.active {
      display: block;
    }

    .recording-modal h4 {
      display: none;
    }

    .recording-timer {
      font-size: 16px;
      color: #ff6b6b;
      font-weight: 600;
      text-align: center;
      margin: 0;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .recording-timer::before {
      content: '‚óè';
      display: inline-block;
      animation: pulse 1s infinite;
    }

    .recording-waveform {
      display: none;
    }

    .recording-waveform canvas {
      display: none;
    }

    .recording-controls {
      display: none;
    }

    .recording-controls button {
      display: none;
    }

    .recording-controls .stop-btn {
      display: none;
    }

    .recording-controls .stop-btn:hover {
      display: none;
    }

    .recording-controls .cancel-btn {
      display: none;
    }

    .recording-controls .cancel-btn:hover {
      display: none;
    }

    .playback-controls {
      display: none;
    }

    .playback-controls button {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: all 0.2s;
    }

    .playback-controls .send-btn {
      background: #00a884;
      color: white;
    }

    .playback-controls .send-btn:hover {
      background: #008f6c;
    }

    .playback-controls .delete-btn {
      background: #ff6b6b;
      color: white;
    }

    .playback-controls .delete-btn:hover {
      background: #ff5252;
    }


    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #667781;
    }

    .empty-state h3 {
      margin-top: 20px;
      font-size: 20px;
    }

    .empty-state p {
      margin-top: 10px;
      font-size: 14px;
    }

    .empty-state-reminders {
      margin-top: 22px;
      width: min(92%, 520px);
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 14px;
      padding: 12px 14px;
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.08);
      display: none;
      flex-direction: column;
      gap: 10px;
      text-align: left;
    }

    .empty-state-reminders-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 13px;
      font-weight: 600;
      color: #0f172a;
    }

    .empty-state-reminders-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 230px;
      overflow: auto;
      padding-right: 2px;
    }

    .empty-reminder-item {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      text-align: left;
    }

    .empty-reminder-title {
      font-size: 13px;
      font-weight: 600;
      color: #0f172a;
    }

    .empty-reminder-meta {
      font-size: 12px;
      color: #64748b;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .empty-reminder-note,
    .empty-reminder-message {
      font-size: 12px;
      color: #334155;
    }

    .empty-reminder-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    /* Modal de Confirma√ß√£o */
    .confirmation-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .confirmation-modal.active {
      display: flex;
    }

    .confirmation-modal-content {
      background: white;
      border-radius: 12px;
      padding: 30px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .confirmation-modal-header {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 15px;
      color: #111;
    }

    .confirmation-modal-message {
      font-size: 14px;
      color: #667781;
      margin-bottom: 25px;
      line-height: 1.5;
    }

    .confirmation-modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .btn-cancel {
      padding: 10px 25px;
      background: #f0f2f5;
      color: #667781;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
    }

    .btn-cancel:hover {
      background: #e5e5e5;
    }

    .btn-confirm {
      padding: 10px 25px;
      background: #ff6b6b;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: background 0.2s;
    }

    .btn-confirm:hover {
      background: #ff5252;
    }

    /* Toast de Alerta */
    .custom-toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: white;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 10000;
      animation: slideInRight 0.3s ease;
      max-width: 350px;
      border-left: 4px solid #00a884;
    }

    .custom-toast.error {
      border-left-color: #ff6b6b;
    }

    .custom-toast.warning {
      border-left-color: #ffa500;
    }

    .custom-toast-icon {
      font-size: 20px;
      flex-shrink: 0;
    }

    .custom-toast-message {
      flex: 1;
      font-size: 14px;
      color: #111;
    }

    .custom-toast-close {
      background: none;
      border: none;
      font-size: 18px;
      color: #667781;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }

    .custom-toast.hiding {
      animation: slideOutRight 0.3s ease;
    }

    /* Bot√£o de voltar para mobile */
    .back-button {
      display: none;
      padding: 8px;
      background: none;
      border: none;
      cursor: pointer;
      color: #111;
      font-size: 20px;
      margin-right: 10px;
    }

    /* Responsividade para Mobile */
    @media (max-width: 768px) {
      .back-button {
        display: inline-block;
      }

      .tickets-panel {
        width: 100%;
        position: absolute;
        z-index: 10;
        transition: transform 0.3s;
        left: 0;
        top: 0;
        bottom: 0;
      }

      .tickets-panel.hide-mobile {
        transform: translateX(-100%);
        visibility: hidden;
      }

      .chat-panel {
        width: 100%;
        position: absolute;
        z-index: 9;
        left: 0;
        top: 0;
        bottom: 0;
      }

      #chatArea {
        display: flex !important;
      }

      .panel-header h2 {
        font-size: 16px;
      }

      .chat-header {
        padding: 12px 15px;
      }

      .chat-header h3 {
        font-size: 14px;
      }

      .chat-actions {
        flex-direction: column;
        gap: 8px;
      }

      #adminSellerSelect {
        margin-right: 0 !important;
        margin-bottom: 5px;
      }

      #statusSelect {
        font-size: 12px;
        padding: 6px 10px;
      }

      .message-input-area {
        padding: 10px;
      }

      .message-input {
        font-size: 14px;
      }

      .send-button {
        padding: 10px 15px;
        font-size: 13px;
      }

      .ticket-item {
        padding: 12px;
      }

      .message-bubble {
        max-width: 85%;
        font-size: 14px;
      }

      .confirmation-modal-content {
        width: 90%;
        max-width: 350px;
        padding: 20px;
      }

      .chat-reminders {
        padding: 8px 12px;
      }

      .reminders-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .reminder-btn {
        width: 100%;
      }

      .reminder-modal-card {
        width: min(94vw, 520px);
      }

      .reminder-modal-body {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 480px) {
      .panel-header {
        padding: 15px;
      }

      .chat-header {
        padding: 10px;
      }

      .message-input-area {
        padding: 8px;
      }

      .send-button {
        padding: 8px 12px;
        font-size: 12px;
      }

      .custom-toast {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
        font-size: 13px;
      }

      .custom-select {
        min-width: 120px;
      }

      .custom-select-trigger {
        font-size: 12px;
        padding: 6px 25px 6px 10px;
      }

      .custom-select-option {
        font-size: 12px;
        padding: 8px 10px;
      }

      .reminders-list {
        max-height: 120px;
      }
    }
  </style>
  <link rel="stylesheet" href="/ui.css">
</head>
<body>
  <div class="container">
    <!-- Lista de Tickets -->
    <div class="tickets-panel">
      <div class="panel-header">
        <h2>Conversas</h2>
        <p style="font-size: 13px; opacity: 0.9;">Atendimento WhatsApp</p>
        <div class="user-section" id="userSection" style="display: none;">
          <span id="userNameDisplay"></span>
          <button class="logout-btn" id="logoutBtn">Sair</button>
        </div>
        <div class="admin-actions" id="adminActions" style="display: none;">
          <button class="btn-manage-sellers" id="manageSellersBtn">
            ‚öôÔ∏è Painel Admin
          </button>
        </div>
      </div>
      <div class="tickets-filters">
        <label>
          <input type="checkbox" id="toggleClosedTickets" />
          Mostrar encerrados
        </label>
      </div>
      <div class="tickets-list" id="ticketsList">
        <!-- Tickets ser√£o inseridos aqui -->
      </div>
    </div>

    <!-- Chat -->
    <div class="chat-panel">
      <div id="emptyState" class="empty-state">
        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
        <h3>Selecione uma conversa</h3>
        <p>Escolha um ticket da lista para iniciar o atendimento</p>
        <div class="empty-state-reminders" id="emptyReminders">
          <div class="empty-state-reminders-header">
            <span>‚è∞ Lembretes pendentes</span>
            <button class="reminder-btn secondary" id="emptyRemindersRefreshBtn" type="button">Atualizar</button>
          </div>
          <div class="empty-state-reminders-list" id="emptyRemindersList"></div>
        </div>
      </div>

      <div id="chatArea" style="display: none; flex: 1; flex-direction: column; min-height: 0;">
        <div class="chat-header">
          <div class="chat-info">
            <button class="back-button" id="backToTicketsBtn">‚Üê</button>
            <div id="chatAvatarContainer"></div>
            <div class="chat-text">
              <h3 id="currentPhone"></h3>
              <div class="chat-meta">
                <span id="currentStatus" style="font-size: 12px; color: #667781;"></span>
                <span id="currentTicketStatus" class="status-pill"></span>
              </div>
              <div class="ticket-history" id="ticketHistory"></div>
            </div>
          </div>
          <div class="chat-actions">
            <div id="adminSellerSelect" style="display: none; margin-right: 10px;">
              <label id="sellerSelectLabel" style="font-size: 12px; color: #667781; margin-right: 5px;">Vendedor:</label>
              <select id="sellerSelect" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                <option value="">N√£o atribu√≠do</option>
              </select>
            </div>
            <button class="close-chat-btn" id="closeConversationBtn" type="button">Fechar conversa</button>
            <select id="statusSelect">
              <option value="pendente">Pendente</option>
              <option value="aguardando">Aguardando</option>
              <option value="em_atendimento">Em Atendimento</option>
              <option value="resolvido">Resolvido</option>
              <option value="encerrado">Encerrado</option>
            </select>
          </div>
        </div>

        <div class="chat-reminders" id="chatReminders" style="display: none;">
          <div class="reminders-header">
            <div class="reminders-title">Lembretes da conversa</div>
            <button class="reminder-btn" id="openReminderBtn" type="button">‚è∞ Agendar</button>
          </div>
        </div>

        <div class="messages-container" id="messagesContainer">
          <!-- Mensagens ser√£o inseridas aqui -->
        </div>

        <div class="reply-preview" id="replyPreview">
          <div class="reply-preview-header">
            <span>Respondendo a:</span>
            <button class="reply-preview-close" id="replyCloseBtn">‚úï</button>
          </div>
          <div class="reply-preview-content" id="replyPreviewContent"></div>
        </div>

        <div class="message-input-area">
          <textarea 
            id="messageInput" 
            class="message-input" 
            placeholder="Digite sua mensagem..."
            rows="1"
          ></textarea>
          <button class="audio-button" id="recordBtn" title="Clique para gravar (desktop) ou segure (mobile)">
            üé§
          </button>
          <button class="send-button" id="sendBtn">Enviar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de Grava√ß√£o de √Åudio -->
  <div class="recording-modal" id="recordingModal">
    <div class="recording-timer" id="recordingTimer">Gravando 00:00</div>
  </div>

  <!-- Modal de Confirma√ß√£o -->
  <div class="confirmation-modal" id="confirmModal">
    <div class="confirmation-modal-content">
      <div class="confirmation-modal-header" id="confirmModalHeader">‚ö†Ô∏è Confirma√ß√£o</div>
      <div class="confirmation-modal-message" id="confirmModalMessage"></div>
      <div class="confirmation-modal-actions">
        <button class="btn-cancel" id="confirmModalCancel">Cancelar</button>
        <button class="btn-confirm" id="confirmModalConfirm">Confirmar</button>
      </div>
    </div>
  </div>

  <!-- Modal de Agendamento -->
  <div class="reminder-modal" id="reminderModal">
    <div class="reminder-modal-card">
      <div class="reminder-modal-header">
        <div>
          <div class="reminder-modal-title">‚è∞ Agendar lembrete</div>
          <div class="reminder-modal-subtitle">Defina quando retomar esta conversa</div>
        </div>
        <button class="reminder-modal-close" id="reminderModalClose" aria-label="Fechar">‚úï</button>
      </div>
      <div class="reminder-modal-body">
        <label class="reminder-field" data-icon="calendar">
          <span>Data</span>
          <button type="button" class="reminder-picker-trigger" id="reminderDateTrigger">
            <span id="reminderDateDisplay">Selecione a data</span>
            <span class="picker-caret">‚ñæ</span>
          </button>
          <input type="hidden" id="reminderDate" />
          <div class="reminder-picker" id="reminderDatePicker" aria-hidden="true">
            <div class="picker-header">
              <button type="button" class="picker-nav" id="reminderPrevMonth">‚Äπ</button>
              <div class="picker-month" id="reminderMonthLabel"></div>
              <button type="button" class="picker-nav" id="reminderNextMonth">‚Ä∫</button>
            </div>
            <div class="picker-weekdays">
              <span>Dom</span><span>Seg</span><span>Ter</span><span>Qua</span><span>Qui</span><span>Sex</span><span>S√°b</span>
            </div>
            <div class="picker-days" id="reminderCalendarDays"></div>
          </div>
        </label>
        <label class="reminder-field" data-icon="clock">
          <span>Hora</span>
          <button type="button" class="reminder-picker-trigger" id="reminderTimeTrigger">
            <span class="time-trigger-label">
              <span class="clock-icon" aria-hidden="true"></span>
              <span id="reminderTimeDisplay">Selecione a hora</span>
            </span>
            <span class="picker-caret">‚ñæ</span>
          </button>
          <input type="hidden" id="reminderTime" />
          <div class="reminder-picker" id="reminderTimePicker" aria-hidden="true">
            <div class="picker-header clock-picker-header">
              <div class="clock-picker-title">
                <span class="clock-icon" aria-hidden="true"></span>
                <div class="clock-time-display" aria-live="polite">
                  <button type="button" class="clock-time-part" id="clockHourBtn" aria-label="Selecionar hora">00</button>
                  <span class="clock-time-sep">:</span>
                  <button type="button" class="clock-time-part" id="clockMinuteBtn" aria-label="Selecionar minutos">00</button>
                </div>
              </div>
              <div class="clock-step-hint" id="clockStepHint">Escolha a hora</div>
            </div>
            <div class="clock-picker-body">
              <div class="clock-face" id="clockFace" tabindex="0" aria-label="Selecionar hor√°rio">
                <div class="clock-markers" id="clockMarkers" aria-hidden="true"></div>
                <div class="clock-hand" id="clockHand"></div>
                <div class="clock-center" id="clockCenter"></div>
              </div>
              <div class="clock-footer">
                <button type="button" class="clock-action" id="clockNowBtn">Agora</button>
                <button type="button" class="clock-action primary" id="clockConfirmBtn">Ok</button>
              </div>
            </div>
          </div>
        </label>
        <label class="reminder-field full" data-icon="note">
          <span>Observa√ß√£o</span>
          <textarea id="reminderNote" rows="3" placeholder="Ex.: retomar contato sobre or√ßamento"></textarea>
        </label>
        <label class="reminder-field full" data-icon="note">
          <span>Mensagem pronta</span>
          <textarea id="reminderMessage" rows="3" placeholder="Mensagem que ser√° preenchida ao abrir o lembrete"></textarea>
        </label>
        <div class="reminder-list-section">
          <div class="reminder-list-title">Lembretes agendados</div>
          <div class="reminders-list" id="remindersList"></div>
        </div>
      </div>
      <div class="reminder-modal-actions">
        <button class="reminder-btn secondary" id="reminderCancelBtn" type="button">Cancelar</button>
        <button class="reminder-btn" id="reminderSaveBtn" type="button">Salvar lembrete</button>
      </div>
    </div>
  </div>

  <!-- Lightbox para imagens -->
  <div class="image-lightbox" id="imageLightbox">
    <img id="lightboxImage" src="" alt="Imagem">
  </div>

  <script>
    // Use URLs relativas para evitar problemas de protocolo (http/https) e CORS.
    const API_URL = '';
    let currentTicket = null;
    let ticketSelectionToken = 0;
    let ticketSelectAbortController = null;
    let messagesAbortController = null;
    let updateInterval = null;
    let isLoadingTickets = false;
    let pendingTicketsRefresh = false;
    let lastTicketsData = null;
    let profilePictureCache = {};
    const PROFILE_PIC_CACHE_TTL_MS = 6 * 60 * 60 * 1000; // 6h
    const PROFILE_PIC_CACHE_MAX = 800;
    let reminderPollTimer = null;
    let showClosedTickets = false;
    const reminderPickerState = {
      month: new Date(),
      selectedDate: null,
      selectedHour: null,
      selectedMinute: null,
      open: null,
    };
    let reminderPickersReady = false;
    let isConnected = false;
    let userId = null;
    let userType = null;
    let userName = null;
    let sellers = [];
    let tickets = [];
    const MESSAGES_PAGE_SIZE = 200;
    let earliestMessageTimestamp = {};
    let isLoadingOlder = {};
    let allHistoryLoaded = {};
    let lazyMediaObserver = null;
    const TICKETS_PAGE_SIZE = 60;
    let ticketsOffset = 0;
    let allTicketsLoaded = false;
    let isLoadingMoreTickets = false;
    let currentReminders = [];
    let reminderEditId = null;

    function pruneProfilePictureCache() {
      try {
        const now = Date.now();
        const entries = Object.entries(profilePictureCache);
        if (!entries.length) return;

        // Remove expirados
        for (const [k, v] of entries) {
          const ts = v && typeof v._ts === 'number' ? v._ts : 0;
          if (!ts || (now - ts) > PROFILE_PIC_CACHE_TTL_MS) {
            delete profilePictureCache[k];
          }
        }

        // Limita tamanho (remove mais antigos)
        const remaining = Object.entries(profilePictureCache);
        if (remaining.length <= PROFILE_PIC_CACHE_MAX) return;
        remaining.sort((a, b) => ((a[1] && a[1]._ts) || 0) - ((b[1] && b[1]._ts) || 0));
        const toDrop = remaining.length - PROFILE_PIC_CACHE_MAX;
        for (let i = 0; i < toDrop; i++) {
          delete profilePictureCache[remaining[i][0]];
        }
      } catch (_) {}
    }

    // Fun√ß√£o para formatar hor√°rio de mensagem com fuso hor√°rio correto (Brasil)
    function formatMessageTime(datetimeStr) {
      if (!datetimeStr) return '00:00';
      try {
        // SQLite CURRENT_TIMESTAMP retorna em UTC (YYYY-MM-DD HH:MM:SS)
        // Precisamos converter para hor√°rio local do Brasil (GMT-3 ou GMT-2 com hor√°rio de ver√£o)
        const dateParts = datetimeStr.split(' ');
        const datePart = dateParts[0]; // YYYY-MM-DD
        const timePart = dateParts[1]; // HH:MM:SS
        
        if (!timePart) {
          // Se for ISO format com T
          const isoDate = new Date(datetimeStr);
          return isoDate.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        }
        
        // Parse manual: YYYY-MM-DD HH:MM:SS (UTC)
        const [year, month, day] = datePart.split('-').map(Number);
        const [hours, minutes, seconds] = timePart.split(':').map(Number);
        
        // Cria date em UTC
        const utcDate = new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));
        
        // Converte para hor√°rio local brasileiro
        // Brasil usa GMT-3 (Padr√£o) ou GMT-2 (Hor√°rio de ver√£o)
        const localDate = new Date(utcDate.toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' }));
        
        return localDate.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
      } catch (_) {
        return '00:00';
      }
    }

    function getStatusLabel(status) {
      if (status === 'pendente') return 'Pendente';
      if (status === 'aguardando') return 'Aguardando';
      if (status === 'em_atendimento') return 'Em Atendimento';
      if (status === 'encerrado') return 'Encerrado';
      return 'Resolvido';
    }

    function updateTicketStatusBadge(ticket) {
      const statusEl = document.getElementById('currentTicketStatus');
      if (!statusEl) return;
      if (!ticket || !ticket.status) {
        statusEl.textContent = '';
        statusEl.className = 'status-pill';
        return;
      }
      statusEl.textContent = getStatusLabel(ticket.status);
      statusEl.className = `status-pill status-${ticket.status}`;
    }

    function parseUtcDateTime(value) {
      if (!value) return null;
      const raw = String(value).trim();
      if (!raw) return null;
      const normalized = raw.includes('T') ? raw : raw.replace(' ', 'T');
      const withZone = normalized.endsWith('Z') ? normalized : `${normalized}Z`;
      const d = new Date(withZone);
      if (Number.isNaN(d.getTime())) return null;
      return d;
    }

    function formatReminderDate(value) {
      const d = parseUtcDateTime(value);
      if (!d) return 'Data inv√°lida';
      return d.toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
    }

    function toDatetimeLocalValue(value) {
      const d = value instanceof Date ? value : parseUtcDateTime(value);
      if (!d) return '';
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    function formatDateDisplay(date) {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return 'Selecione a data';
      return date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });
    }

    function formatTimeDisplay(hour, minute) {
      if (hour == null || minute == null) return 'Selecione a hora';
      return `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
    }

    function renderReminderCalendar() {
      const label = document.getElementById('reminderMonthLabel');
      const daysContainer = document.getElementById('reminderCalendarDays');
      if (!label || !daysContainer) return;

      const monthDate = reminderPickerState.month;
      const year = monthDate.getFullYear();
      const month = monthDate.getMonth();
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const daysInMonth = lastDay.getDate();
      const startWeekday = firstDay.getDay();

      label.textContent = firstDay.toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' });
      daysContainer.innerHTML = '';

      for (let i = 0; i < startWeekday; i++) {
        const spacer = document.createElement('div');
        spacer.className = 'picker-day muted';
        daysContainer.appendChild(spacer);
      }

      for (let day = 1; day <= daysInMonth; day++) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'picker-day';
        btn.textContent = String(day);
        const date = new Date(year, month, day);
        if (reminderPickerState.selectedDate && date.toDateString() === reminderPickerState.selectedDate.toDateString()) {
          btn.classList.add('selected');
        }
        btn.addEventListener('click', () => {
          reminderPickerState.selectedDate = date;
          const hidden = document.getElementById('reminderDate');
          const display = document.getElementById('reminderDateDisplay');
          if (hidden) hidden.value = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          if (display) display.textContent = formatDateDisplay(date);
          toggleReminderPicker(null);
        });
        daysContainer.appendChild(btn);
      }
    }

    const clockPickerState = { mode: 'hour' };

    function updateClockHeader() {
      const hourBtn = document.getElementById('clockHourBtn');
      const minuteBtn = document.getElementById('clockMinuteBtn');
      const hint = document.getElementById('clockStepHint');
      const hour = reminderPickerState.selectedHour;
      const minute = reminderPickerState.selectedMinute;

      if (hourBtn) hourBtn.textContent = hour != null ? String(hour).padStart(2, '0') : '--';
      if (minuteBtn) minuteBtn.textContent = minute != null ? String(minute).padStart(2, '0') : '--';

      if (hourBtn) hourBtn.classList.toggle('active', clockPickerState.mode === 'hour');
      if (minuteBtn) minuteBtn.classList.toggle('active', clockPickerState.mode === 'minute');

      if (hint) hint.textContent = clockPickerState.mode === 'hour' ? 'Escolha a hora' : 'Escolha os minutos';
    }

    function updateClockHand() {
      const hand = document.getElementById('clockHand');
      if (!hand) return;
      const mode = clockPickerState.mode;
      const value = mode === 'hour'
        ? (reminderPickerState.selectedHour ?? 0)
        : (reminderPickerState.selectedMinute ?? 0);
      const max = mode === 'hour' ? 24 : 60;
      const angle = (value / max) * 360;
      hand.style.transform = `translateX(-50%) rotate(${angle}deg)`;
    }

    function setClockMode(mode) {
      clockPickerState.mode = mode;
      updateClockHeader();
      renderClockFace();
    }

    function selectClockValue(value) {
      if (clockPickerState.mode === 'hour') {
        reminderPickerState.selectedHour = value;
        updateTimeValue();
        setClockMode('minute');
        const face = document.getElementById('clockFace');
        if (face) setTimeout(() => face.focus(), 0);
        return;
      }

      reminderPickerState.selectedMinute = value;
      updateTimeValue();
      toggleReminderPicker(null);
    }

    function renderClockFace() {
      const face = document.getElementById('clockFace');
      const markers = document.getElementById('clockMarkers');
      if (!face) return;

      if (!markers) return;
      markers.innerHTML = '';
      face.querySelectorAll('.clock-marker').forEach(el => el.remove());

      const size = face.clientWidth || face.offsetWidth || 0;
      if (size < 50) {
        requestAnimationFrame(renderClockFace);
        return;
      }
      const mode = clockPickerState.mode;
      const count = mode === 'hour' ? 24 : 60;
      const baseSize = Math.floor(size * (mode === 'hour' ? 0.12 : 0.11));
      const markerSize = Math.max(30, Math.min(40, baseSize));
      const dotSize = Math.max(10, Math.min(14, Math.floor(markerSize * 0.32)));
      const radius = size / 2 - markerSize / 2 - 2;
      const center = size / 2;
      const selected = mode === 'hour' ? reminderPickerState.selectedHour : reminderPickerState.selectedMinute;

      const fragment = document.createDocumentFragment();
      for (let i = 0; i < count; i += 1) {
        const angle = (i / count) * (Math.PI * 2) - Math.PI / 2;
        const x = Math.round(center + radius * Math.cos(angle));
        const y = Math.round(center + radius * Math.sin(angle));

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'clock-marker';
        const isDot = mode === 'minute' && i % 5 !== 0;
        const finalSize = isDot ? dotSize : markerSize;
        btn.style.width = `${finalSize}px`;
        btn.style.height = `${finalSize}px`;
        btn.style.left = `${x}px`;
        btn.style.top = `${y}px`;
        btn.style.transform = 'translate(-50%, -50%)';

        if (isDot) {
          btn.classList.add('dot');
          btn.textContent = '‚Ä¢';
        } else {
          btn.textContent = String(i).padStart(2, '0');
        }

        btn.setAttribute('aria-label', mode === 'hour' ? `Hora ${String(i).padStart(2, '0')}` : `Minuto ${String(i).padStart(2, '0')}`);

        if (selected === i) btn.classList.add('selected');
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          selectClockValue(i);
        });
        fragment.appendChild(btn);
      }

      markers.appendChild(fragment);
      if (mode === 'hour') {
        console.debug('[clock-picker] hour markers:', markers.children.length);
      }

      updateClockHand();
    }

    function handleClockKeydown(event) {
      const mode = clockPickerState.mode;
      const max = mode === 'hour' ? 24 : 60;
      let current = mode === 'hour' ? reminderPickerState.selectedHour : reminderPickerState.selectedMinute;
      if (current == null) current = 0;

      let next = current;
      if (event.key === 'ArrowRight') next = (current + 1) % max;
      if (event.key === 'ArrowLeft') next = (current - 1 + max) % max;
      if (event.key === 'ArrowUp') next = (current + (mode === 'hour' ? -3 : -5) + max * 10) % max;
      if (event.key === 'ArrowDown') next = (current + (mode === 'hour' ? 3 : 5)) % max;
      if (event.key === 'Home') next = 0;
      if (event.key === 'End') next = max - 1;

      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        selectClockValue(current);
        return;
      }

      if (event.key === 'Escape') {
        event.preventDefault();
        toggleReminderPicker(null);
        return;
      }

      if (next !== current) {
        event.preventDefault();
        if (mode === 'hour') reminderPickerState.selectedHour = next;
        if (mode === 'minute') reminderPickerState.selectedMinute = next;
        updateTimeValue();
        renderClockFace();
      }
    }

    function initClockPicker() {
      const face = document.getElementById('clockFace');
      const hourBtn = document.getElementById('clockHourBtn');
      const minuteBtn = document.getElementById('clockMinuteBtn');
      const nowBtn = document.getElementById('clockNowBtn');
      const confirmBtn = document.getElementById('clockConfirmBtn');

      if (!face) return;

      if (face.dataset.clockInit !== '1') {
        face.dataset.clockInit = '1';
        face.addEventListener('click', (e) => e.stopPropagation());
        face.addEventListener('keydown', handleClockKeydown);

        if (hourBtn) {
          hourBtn.addEventListener('click', () => setClockMode('hour'));
        }
        if (minuteBtn) {
          minuteBtn.addEventListener('click', () => setClockMode('minute'));
        }
        if (nowBtn) {
          nowBtn.addEventListener('click', () => {
            const now = new Date();
            reminderPickerState.selectedHour = now.getHours();
            reminderPickerState.selectedMinute = now.getMinutes();
            updateTimeValue();
            setClockMode('minute');
            toggleReminderPicker(null);
          });
        }
        if (confirmBtn) {
          confirmBtn.addEventListener('click', () => {
            if (reminderPickerState.selectedHour == null) {
              reminderPickerState.selectedHour = new Date().getHours();
            }
            if (reminderPickerState.selectedMinute == null) {
              reminderPickerState.selectedMinute = 0;
            }
            updateTimeValue();
            toggleReminderPicker(null);
          });
        }
      }

      updateClockHeader();
      renderClockFace();
    }

    function updateTimeValue() {
      const hidden = document.getElementById('reminderTime');
      const display = document.getElementById('reminderTimeDisplay');
      const hour = reminderPickerState.selectedHour;
      const minute = reminderPickerState.selectedMinute;
      if (hour == null && minute == null) {
        if (hidden) hidden.value = '';
        if (display) display.textContent = 'Selecione a hora';
        updateClockHeader();
        return;
      }

      const hourLabel = hour != null ? String(hour).padStart(2, '0') : '--';
      const minuteLabel = minute != null ? String(minute).padStart(2, '0') : '--';
      if (display) display.textContent = `${hourLabel}:${minuteLabel}`;

      if (hour != null && minute != null) {
        if (hidden) hidden.value = `${hourLabel}:${minuteLabel}`;
      } else if (hidden) {
        hidden.value = '';
      }

      updateClockHeader();
    }

    function toggleReminderPicker(which) {
      const datePicker = document.getElementById('reminderDatePicker');
      const timePicker = document.getElementById('reminderTimePicker');
      reminderPickerState.open = which;
      if (datePicker) datePicker.classList.toggle('active', which === 'date');
      if (timePicker) timePicker.classList.toggle('active', which === 'time');
      if (which === 'time') {
        const mode = reminderPickerState.selectedHour == null ? 'hour' : 'minute';
        setClockMode(mode);
        const face = document.getElementById('clockFace');
        if (face) setTimeout(() => face.focus(), 0);
      }
    }

    function initReminderPickers() {
      if (reminderPickersReady) return;
      reminderPickersReady = true;
      const dateTrigger = document.getElementById('reminderDateTrigger');
      const timeTrigger = document.getElementById('reminderTimeTrigger');
      const prevBtn = document.getElementById('reminderPrevMonth');
      const nextBtn = document.getElementById('reminderNextMonth');

      if (dateTrigger) {
        dateTrigger.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const next = reminderPickerState.open === 'date' ? null : 'date';
          toggleReminderPicker(next);
        });
      }

      if (timeTrigger) {
        timeTrigger.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const next = reminderPickerState.open === 'time' ? null : 'time';
          toggleReminderPicker(next);
        });
      }

      if (prevBtn) {
        prevBtn.addEventListener('click', () => {
          reminderPickerState.month = new Date(reminderPickerState.month.getFullYear(), reminderPickerState.month.getMonth() - 1, 1);
          renderReminderCalendar();
        });
      }

      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          reminderPickerState.month = new Date(reminderPickerState.month.getFullYear(), reminderPickerState.month.getMonth() + 1, 1);
          renderReminderCalendar();
        });
      }

      document.addEventListener('click', (event) => {
        const datePicker = document.getElementById('reminderDatePicker');
        const timePicker = document.getElementById('reminderTimePicker');
        const dateTriggerEl = document.getElementById('reminderDateTrigger');
        const timeTriggerEl = document.getElementById('reminderTimeTrigger');
        if (!datePicker || !timePicker) return;
        if (datePicker.contains(event.target) || timePicker.contains(event.target) || dateTriggerEl?.contains(event.target) || timeTriggerEl?.contains(event.target)) {
          return;
        }
        toggleReminderPicker(null);
      });

      renderReminderCalendar();
      initClockPicker();
    }

    // Verifica autentica√ß√£o via sess√£o
    async function checkAuth() {
      try {
        const response = await fetch(`${API_URL}/auth/session`, {
          credentials: 'include' // Importante para enviar cookies de sess√£o
        });

        if (!response.ok) {
          // Sem autentica√ß√£o, redireciona para login
          if (typeof navigateTo === 'function') navigateTo('/login'); else window.location.href = '/login';
          return;
        }

        const data = await response.json();
        userId = parseInt(data.userId, 10);
        if (Number.isNaN(userId)) {
          userId = data.userId;
        }
        userType = data.userType;
        userName = data.userName;

        // Mostra informa√ß√µes do usu√°rio no header
        const userSection = document.getElementById('userSection');
        const userNameDisplay = document.getElementById('userNameDisplay');
        const adminActions = document.getElementById('adminActions');
        
        if (userSection && userNameDisplay) {
          if (userType === 'admin') {
            userNameDisplay.textContent = `üë®‚Äçüíª ${userName} (Admin)`;
            // Mostra bot√£o de gerenciar vendedores para admin
            if (adminActions) {
              adminActions.style.display = 'block';
            }
            // Carrega lista de vendedores para o admin
            await loadSellers();
          } else {
            userNameDisplay.textContent = `üë§ ${userName}`;
            await loadSellers();
          }
          userSection.style.display = 'flex';
        }
      } catch (error) {
        if (typeof navigateTo === 'function') navigateTo('/login'); else window.location.href = '/login';
      }
    }

    // Carrega lista de vendedores (admin e vendedores)
    async function loadSellers() {
      if (!userType) return;
      
      try {
        const endpoint = userType === 'admin' ? `${API_URL}/assignees` : `${API_URL}/sellers/active`;
        const response = await fetch(endpoint, {
          credentials: 'include',
          cache: 'no-store'
        });

        if (!response.ok) {
          throw new Error('Erro ao carregar vendedores');
        }

        sellers = await response.json();
      } catch (error) {
        // Erro ao carregar vendedores
      }
    }

    async function logout() {
      try {
        await fetch(`${API_URL}/auth/logout`, {
          method: 'POST',
          credentials: 'include'
        });
      } catch (error) {
        // Ignora erros de logout
      }
      if (typeof navigateTo === 'function') navigateTo('/login'); else window.location.href = '/login';
    }

    // Verifica status da conex√£o
    async function checkConnectionStatus() {
      try {
        const response = await fetch(`${API_URL}/connection-status`);
        const data = await response.json();
        isConnected = data.connected;
        
        // Atualiza UI com indicador de status
        updateConnectionIndicator(data.connected);
      } catch (error) {
        isConnected = false;
        updateConnectionIndicator(false);
      }
    }

    // Atualiza indicador visual da conex√£o
    function updateConnectionIndicator(connected) {
      const sendButton = document.querySelector('.send-button');
      const messageInput = document.getElementById('messageInput');
      const audioBtn = document.querySelector('.audio-button');
      
      // Verifica se o ticket atual est√° bloqueado (antigo ou encerrado)
      const shouldBlockInput = currentTicket && (
        currentTicket.isLatestTicket === false || 
        currentTicket.status === 'resolvido' || 
        currentTicket.status === 'encerrado'
      );
      
      if (connected && !shouldBlockInput) {
        if (sendButton) {
          sendButton.disabled = false;
          sendButton.title = '';
        }
        if (messageInput) {
          messageInput.disabled = false;
          messageInput.placeholder = 'Digite sua mensagem...';
        }
        if (audioBtn) {
          audioBtn.disabled = false;
        }
      } else if (shouldBlockInput) {
        // Mant√©m bloqueado se for ticket antigo/encerrado
        if (sendButton) {
          sendButton.disabled = true;
          sendButton.title = '';
        }
        if (messageInput) {
          messageInput.disabled = true;
          messageInput.placeholder = 'N√£o √© poss√≠vel enviar mensagens em tickets antigos ou encerrados.';
        }
        if (audioBtn) {
          audioBtn.disabled = true;
        }
      } else {
        // Desconectado
        if (sendButton) {
          sendButton.disabled = true;
          sendButton.title = 'WhatsApp desconectado. Aguarde a reconex√£o.';
        }
        if (messageInput) {
          messageInput.disabled = true;
          messageInput.placeholder = 'Aguardando conex√£o do WhatsApp...';
        }
        if (audioBtn) {
          audioBtn.disabled = true;
        }
      }
    }

    function renderTicketItem(div, ticket) {
      div.className = `ticket-item ${currentTicket && currentTicket.id === ticket.id ? 'active' : ''}`;
      div.onclick = () => selectTicket(ticket);
      div.dataset.ticketId = String(ticket.id);
      div.dataset.phone = String(ticket.phone || '');

      const statusClass = `status-${ticket.status}`;
      const statusLabel = ticket.status === 'pendente' ? 'Pendente' :
                         ticket.status === 'aguardando' ? 'Aguardando' :
                         ticket.status === 'em_atendimento' ? 'Em Atendimento' :
                         ticket.status === 'encerrado' ? 'Encerrado' : 'Resolvido';

      const firstLetter = (ticket.contact_name || ticket.phone || '').charAt(0).toUpperCase();
      const avatarPlaceholder = `<div class="ticket-default-avatar avatar-placeholder">${firstLetter}</div>`;

      // Evita "piscar": se j√° existe avatar renderizado no item, preserva.
      const existingAvatarEl = div.querySelector('img.ticket-avatar, .ticket-default-avatar');
      const preservedAvatarHtml = existingAvatarEl ? existingAvatarEl.outerHTML : '';
      const avatarHtmlToRender = preservedAvatarHtml || avatarPlaceholder;

      const displayName = ticket.contact_name || ticket.phone;
      const phoneSubtext = ticket.contact_name ? `<div style="font-size: 11px; color: #667781;">${ticket.phone}</div>` : '';

      let sellerBadge = '';
      if (userType === 'admin') {
        if (ticket.seller_name) {
          sellerBadge = `<span class="ticket-seller-badge">üë§ ${ticket.seller_name}</span>`;
        } else {
          sellerBadge = `<span class="ticket-unassigned-badge">‚ö†Ô∏è N√£o atribu√≠do</span>`;
        }
      }

      div.innerHTML = `
        ${avatarHtmlToRender}
        <div class="ticket-content">
          <div class="ticket-phone">${displayName}</div>
          ${phoneSubtext}
          ${sellerBadge}
          <div class="ticket-meta">
            <span class="ticket-status ${statusClass}">${statusLabel}</span>
            <span>${formatMessageTime(ticket.updated_at)}</span>
          </div>
        </div>
      `;

      // Se o item foi re-renderizado com placeholder, permite lazy-load novamente.
      if (div.querySelector('.avatar-placeholder')) {
        if (div.dataset.avatarLoaded === '1') div.dataset.avatarLoaded = '';
      } else if (div.querySelector('img.ticket-avatar')) {
        div.dataset.avatarLoaded = '1';
      }

      // avatar lazy-load (evita muitas chamadas em listas grandes)
      try {
        initTicketAvatarObserver();
        if (window._ticketAvatarObserver) {
          window._ticketAvatarObserver.observe(div);
        }
      } catch (_) {}
    }

    function initTicketAvatarObserver() {
      if (window._ticketAvatarObserver) return;
      const list = document.getElementById('ticketsList');
      if (!list) return;

      window._ticketAvatarObserver = new IntersectionObserver((entries) => {
        entries.forEach(async (entry) => {
          if (!entry.isIntersecting) return;
          const item = entry.target;
          const phone = item && item.dataset ? item.dataset.phone : null;
          if (!phone || item.dataset.avatarLoaded === '1') {
            try { window._ticketAvatarObserver.unobserve(item); } catch (_) {}
            return;
          }
          item.dataset.avatarLoaded = '1';
          try {
            const avatarHtml = await getProfilePictureHtml(phone, 'list');
            const placeholder = item.querySelector('.avatar-placeholder');
            if (placeholder) {
              const wrapper = document.createElement('div');
              wrapper.innerHTML = avatarHtml;
              placeholder.replaceWith(wrapper.firstElementChild);
            }
          } catch (_) {}
          try { window._ticketAvatarObserver.unobserve(item); } catch (_) {}
        });
      }, {
        root: list,
        rootMargin: '240px 0px',
        threshold: 0.01
      });
    }

    function dedupeTicketsByPhone(list) {
      const items = Array.isArray(list) ? list : [];
      if (!items.length) return [];
      const seen = new Set();
      const result = [];
      for (const t of items) {
        const rawPhone = t && t.phone != null ? String(t.phone) : '';
        const key = rawPhone ? rawPhone.split('@')[0] : `id:${t?.id}`;
        if (seen.has(key)) continue;
        seen.add(key);
        result.push(t);
      }
      return result;
    }

    async function loadTickets({ append = false, refreshTop = false } = {}) {
      if (isLoadingTickets) {
        if (!append) pendingTicketsRefresh = true;
        return;
      }
      if (append && (allTicketsLoaded || isLoadingMoreTickets)) return;
      isLoadingTickets = true;
      if (append) isLoadingMoreTickets = true;
      
      try {
        const baseEndpoint = userType === 'admin' 
          ? `${API_URL}/admin/tickets?includeAll=1`
          : `${API_URL}/tickets/seller/${userId}`;

        const offset = append ? ticketsOffset : 0;
        const includeClosedParam = showClosedTickets ? '&includeClosed=1' : '';
        const separator = baseEndpoint.includes('?') ? '&' : '?';
        const endpoint = `${baseEndpoint}${separator}limit=${TICKETS_PAGE_SIZE}&offset=${offset}${includeClosedParam}`;

        const fetchFn = (typeof smartJson === 'function') ? smartJson : async (u, o) => {
          const r = await fetch(u, o);
          if (!r.ok) throw new Error(`HTTP ${r.status}`);
          return r.json();
        };

        const ticketsRaw = await fetchFn(endpoint, { credentials: 'include', cache: 'no-store', maxRetries: 1 });
        const tickets = dedupeTicketsByPhone(ticketsRaw);

        const ticketsList = document.getElementById('ticketsList');

        if (!append) {
          // Reordena a lista para refletir o updated_at (mais recentes no topo)
          const scrollPos = ticketsList.scrollTop;
          const existingNodes = new Map();
          ticketsList.querySelectorAll('[data-ticket-id]').forEach(el => {
            existingNodes.set(String(el.dataset.ticketId), el);
          });

          const fragment = document.createDocumentFragment();
          tickets.forEach(ticket => {
            const key = String(ticket.id);
            let el = existingNodes.get(key);
            if (el) {
              renderTicketItem(el, ticket);
              existingNodes.delete(key);
            } else {
              el = document.createElement('div');
              renderTicketItem(el, ticket);
            }
            fragment.appendChild(el);
          });

          ticketsList.innerHTML = '';
          ticketsList.appendChild(fragment);
          ticketsOffset = 0;
          allTicketsLoaded = false;

          if (scrollPos > 0) {
            setTimeout(() => { ticketsList.scrollTop = scrollPos; }, 10);
          }
        } else {
          for (const ticket of tickets) {
            const existing = ticketsList.querySelector(`[data-ticket-id="${ticket.id}"]`);
            if (existing) {
              renderTicketItem(existing, ticket);
              continue;
            }
            const div = document.createElement('div');
            renderTicketItem(div, ticket);
            ticketsList.appendChild(div);
          }
          ticketsOffset += ticketsRaw.length;
          if (ticketsRaw.length < TICKETS_PAGE_SIZE) allTicketsLoaded = true;
        }

        window.latestTickets = ticketsRaw;
        if (currentTicket) {
          const refreshed = ticketsRaw.find(t => t.id === currentTicket.id);
          if (refreshed) {
            currentTicket = refreshed;
            try { updateHeaderFromTicket(currentTicket); } catch (e) {}
          }
        }
      } catch (error) {
        // Erro ao carregar tickets
      } finally {
        isLoadingTickets = false;
        isLoadingMoreTickets = false;
        if (pendingTicketsRefresh) {
          pendingTicketsRefresh = false;
          loadTickets({ append: false, refreshTop: true });
        }
      }
    }

    // Atualiza selects no header (vendedor e status) com base no currentTicket
    function updateHeaderFromTicket(ticket) {
      if (!ticket) return;
      updateTicketStatusBadge(ticket);
      const statusEl = document.getElementById('currentStatus');
      if (statusEl) {
        statusEl.textContent = ticket.contact_name ? ticket.phone : '';
      }
      const statusSelectEl = document.getElementById('statusSelect');
      if (statusSelectEl) {
        statusSelectEl.value = ticket.status;
        const pendOpt = statusSelectEl.querySelector('option[value="pendente"]');
        if (pendOpt) pendOpt.disabled = ticket.status !== 'pendente';
        updateCustomSelect('statusSelect');
      }

      const sellerSelect = document.getElementById('sellerSelect');
      if (sellerSelect) {
        // repopula op√ß√µes para admin
        if (userType === 'admin') {
          sellerSelect.innerHTML = '<option value="">N√£o atribu√≠do</option>';
          sellers.forEach(s => {
            const opt = document.createElement('option');
            opt.value = s.id;
            opt.textContent = s.name;
            opt.selected = ticket.seller_id === s.id;
            sellerSelect.appendChild(opt);
          });
        }
        if (ticket.seller_id) sellerSelect.value = String(ticket.seller_id); else sellerSelect.value = '';
        updateCustomSelect('sellerSelect');
      }
    }

    function initTicketsInfiniteScroll() {
      const list = document.getElementById('ticketsList');
      if (!list || list.dataset.scrollInit === '1') return;
      list.dataset.scrollInit = '1';
      list.addEventListener('scroll', async () => {
        if (isLoadingTickets || isLoadingMoreTickets || allTicketsLoaded) return;
        const nearBottom = list.scrollTop + list.clientHeight >= list.scrollHeight - 120;
        if (!nearBottom) return;
        await loadTickets({ append: true });
      });
    }

    // Busca foto de perfil
    async function getProfilePictureHtml(phone, type = 'list') {
      const firstLetter = phone.charAt(0).toUpperCase();
      
      // Usa cache para evitar requisi√ß√µes repetidas
      if (profilePictureCache[phone]) {
        const data = profilePictureCache[phone];
        const ts = data && typeof data._ts === 'number' ? data._ts : 0;
        
        // Se est√° em cache h√° menos de 6 horas, usa o cache mesmo que seja null
        if (ts && (Date.now() - ts) < PROFILE_PIC_CACHE_TTL_MS) {
          if (data.url) {
            if (type === 'list') {
              return `<img src="${data.url}" class="ticket-avatar" alt="Avatar">`;
            } else {
              return `<img src="${data.url}" class="chat-avatar" alt="Avatar">`;
            }
          } else {
            // Retorna avatar com letra mesmo que null, mas n√£o tenta buscar novamente
            if (type === 'list') {
              return `<div class="ticket-default-avatar">${firstLetter}</div>`;
            } else {
              return `<div class="chat-default-avatar">${firstLetter}</div>`;
            }
          }
        } else if (!data.url && ts && (Date.now() - ts) < (5 * 60 * 1000)) {
          // Se √© null e foi cacheado a menos de 5 minutos, n√£o tenta buscar novamente
          if (type === 'list') {
            return `<div class="ticket-default-avatar">${firstLetter}</div>`;
          } else {
            return `<div class="chat-default-avatar">${firstLetter}</div>`;
          }
        } else {
          // Cache expirado, remove para buscar novamente
          delete profilePictureCache[phone];
        }
      }
      
      try {
        const response = await fetch(`${API_URL}/profile-picture/${phone}`);
        const data = await response.json();
        
        // Armazena no cache com timestamp
        data._ts = Date.now();
        profilePictureCache[phone] = data;
        pruneProfilePictureCache();
        
        if (data.url) {
          if (type === 'list') {
            return `<img src="${data.url}" class="ticket-avatar" alt="Avatar">`;
          } else {
            return `<img src="${data.url}" class="chat-avatar" alt="Avatar">`;
          }
        } else {
          if (type === 'list') {
            return `<div class="ticket-default-avatar">${firstLetter}</div>`;
          } else {
            return `<div class="chat-default-avatar">${firstLetter}</div>`;
          }
        }
      } catch (error) {
        // Erro de rede ou timeout - n√£o cacheia, vai tentar novamente na pr√≥xima vez
        if (type === 'list') {
          return `<div class="ticket-default-avatar">${firstLetter}</div>`;
        } else {
          return `<div class="chat-default-avatar">${firstLetter}</div>`;
        }
      }
    }

    // Seleciona ticket
    async function selectTicket(ticket) {
      const selectionToken = ++ticketSelectionToken;
      isSelectingTicket = true;
      try {
        if (ticketSelectAbortController) {
          try { ticketSelectAbortController.abort(); } catch (_) {}
        }
        ticketSelectAbortController = new AbortController();
        if (messagesAbortController) {
          try { messagesAbortController.abort(); } catch (_) {}
        }
        messagesAbortController = new AbortController();
        isLoadingMessages = false;
        pendingMessageRefresh = false;

        currentTicket = ticket;
        if (typeof currentTicket.isLatestTicket !== 'boolean') {
          currentTicket.isLatestTicket = true;
        }

        // Garante recarregamento completo ao trocar de ticket
        if (currentTicket && currentTicket.id != null) {
          const tId = currentTicket.id;
          hasLoadedMessages[tId] = false;
          lastMessageTimestamp[tId] = null;
          lastMessageId[tId] = 0;
          earliestMessageTimestamp[tId] = null;
          allHistoryLoaded[tId] = false;
        }

        resetMessageInputForTicket(currentTicket);
        updateMessageInputState(currentTicket);

        document.getElementById('emptyState').style.display = 'none';
        document.getElementById('chatArea').style.display = 'flex';
      
      // Mobile: esconde lista de tickets e mostra o chat
      if (window.innerWidth <= 768) {
        document.querySelector('.tickets-panel').classList.add('hide-mobile');
      }
      
      // Exibe nome do contato ou n√∫mero no cabe√ßalho
      const displayName = ticket.contact_name || ticket.phone;
      document.getElementById('currentPhone').textContent = displayName;
      
      // Exibe n√∫mero abaixo do nome se houver nome de contato
      if (ticket.contact_name) {
        document.getElementById('currentStatus').textContent = ticket.phone;
      } else {
        document.getElementById('currentStatus').textContent = '';
      }
      updateTicketStatusBadge(ticket);

      // Hist√≥rico de tickets desse contato
      try {
        await renderTicketHistory(ticket.phone, ticket.id, { signal: ticketSelectAbortController.signal });
      } catch (_) {}
      if (selectionToken !== ticketSelectionToken) return;
      
      // Detecta se √© o ticket mais recente da conversa
      try {
        const cleanPhone = String(ticket.phone || '').split('@')[0];
        const res = await fetch(`${API_URL}/contacts/${encodeURIComponent(cleanPhone)}/tickets?limit=1&offset=0`, {
          credentials: 'include',
          cache: 'no-store',
          signal: ticketSelectAbortController.signal
        });
        if (res.ok) {
          const latestTickets = await res.json();
          currentTicket.isLatestTicket = Array.isArray(latestTickets) && latestTickets.length > 0 && String(latestTickets[0].id) === String(ticket.id);
        } else {
          currentTicket.isLatestTicket = true;
        }
      } catch (_) {
        currentTicket.isLatestTicket = true;
      }
      if (selectionToken !== ticketSelectionToken) return;
      
      const statusSelectEl = document.getElementById('statusSelect');
      if (statusSelectEl) {
        statusSelectEl.value = ticket.status;
      }
      // Atualiza tamb√©m o custom-select visual (se existir)
      const wrapper = document.querySelector('[data-select-id="statusSelect"]');
      if (wrapper) {
        const optionDivs = wrapper.querySelectorAll('.custom-select-option');
        optionDivs.forEach(div => {
          if (div.dataset.value === 'pendente') {
            div.style.display = ticket.status !== 'pendente' ? 'none' : '';
            if (ticket.status === 'pendente') div.classList.add('selected'); else div.classList.remove('selected');
          }
        });
        const trigger = wrapper.querySelector('.custom-select-trigger');
        if (trigger) {
          const selectedText = statusSelectEl.options[statusSelectEl.selectedIndex]?.text || '';
          trigger.textContent = selectedText;
        }
      }
      updateCustomSelect('statusSelect');
      
      // Se for admin ou vendedor, mostra o select de vendedor
      if (userType === 'admin' || userType === 'seller') {
        const adminSellerDiv = document.getElementById('adminSellerSelect');
        const sellerSelect = document.getElementById('sellerSelect');
        const sellerSelectLabel = document.getElementById('sellerSelectLabel');
        
        if (adminSellerDiv && sellerSelect) {
          adminSellerDiv.style.display = 'flex';
          if (sellerSelectLabel) {
            sellerSelectLabel.textContent = userType === 'admin' ? 'Vendedor:' : 'Transferir para:';
          }
          
          // Popula o select com vendedores
          if (userType === 'admin') {
            sellerSelect.innerHTML = '<option value="">N√£o atribu√≠do</option>';
            sellers.forEach(s => {
              const option = document.createElement('option');
              option.value = s.id;
              option.textContent = s.name;
              option.selected = ticket.seller_id === s.id;
              sellerSelect.appendChild(option);
            });
          } else {
            sellerSelect.innerHTML = '<option value="">Selecionar vendedor</option>';
            const currentUserId = parseInt(userId, 10);
            // Inclui todos os sellers (incluindo o pr√≥prio usu√°rio) para que
            // o dropdown mostre corretamente o vendedor atribu√≠do, mesmo
            // quando for o pr√≥prio usu√°rio.
            sellers.forEach(s => {
              const option = document.createElement('option');
              option.value = s.id;
              option.textContent = s.name;
              option.selected = ticket.seller_id === s.id;
              sellerSelect.appendChild(option);
            });
            // se o ticket estiver atribu√≠do ao pr√≥prio vendedor, garante que apare√ßa selecionado
            if (ticket.seller_id && String(ticket.seller_id) === String(currentUserId)) {
              sellerSelect.value = String(currentUserId);
            }
          }
        }
      }
      
      // Inicializa os selects customizados
      setTimeout(() => {
        initCustomSelects();
        // Atualiza visualmente os selects ap√≥s cria√ß√£o do custom-select
        try { updateCustomSelect('sellerSelect'); } catch (e) {}
        try { updateCustomSelect('statusSelect'); } catch (e) {}
      }, 100);
      
      // Carrega foto de perfil no cabe√ßalho
      const avatarHtml = await getProfilePictureHtml(ticket.phone, 'chat');
      if (selectionToken !== ticketSelectionToken) return;
      document.getElementById('chatAvatarContainer').innerHTML = avatarHtml;

      await loadMessages(ticket.id);
      if (selectionToken !== ticketSelectionToken) return;
      initMessageInfiniteScroll(document.getElementById('messagesContainer'));

      // Controla √°rea de input com base no status do ticket
      updateMessageInputState(ticket);

      const remindersPanel = document.getElementById('chatReminders');
      if (remindersPanel) remindersPanel.style.display = 'flex';
      await loadRemindersForTicket(ticket.id);
      } finally {
        if (selectionToken === ticketSelectionToken) {
          isSelectingTicket = false;
        }
      }
    }

    function resetMessageInputForTicket(ticket) {
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.querySelector('.send-button');
      const audioBtn = document.querySelector('.audio-button');
      const messagesContainer = document.getElementById('messagesContainer');
      const existingNotice = document.getElementById('oldTicketNotice');

      if (messageInput) messageInput.value = '';
      if (sendBtn) sendBtn.disabled = true;
      if (audioBtn) audioBtn.disabled = true;
      if (existingNotice) existingNotice.remove();
      if (messagesContainer) {
        messagesContainer.innerHTML = '';
        messagesContainer.scrollTop = 0;
      }
    }

    function updateMessageInputState(ticket) {
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.querySelector('.send-button');
      const audioBtn = document.querySelector('.audio-button');
      const messagesContainer = document.getElementById('messagesContainer');
      let oldTicketNotice = document.getElementById('oldTicketNotice');
      
      // Verifica se √© um ticket antigo (n√£o √© o mais recente) OU se foi encerrado/resolvido
      const isOldTicket = ticket.isLatestTicket === false;
      const isClosed = ticket.status === 'resolvido' || ticket.status === 'encerrado';
      const shouldBlockInput = isOldTicket || isClosed;
      
      console.log('updateMessageInputState - ticket:', ticket.id, 'isLatestTicket:', ticket.isLatestTicket, 'status:', ticket.status, 'shouldBlockInput:', shouldBlockInput);
      
      if (shouldBlockInput) {
        // Desabilita input e bot√µes para tickets antigos ou encerrados
        if (messageInput) {
          messageInput.disabled = true;
          messageInput.placeholder = 'N√£o √© poss√≠vel enviar mensagens em tickets antigos ou encerrados.';
        }
        if (sendBtn) sendBtn.disabled = true;
        if (audioBtn) audioBtn.disabled = true;
        
        // Remove mensagem anterior se existir
        const existingNotice = document.getElementById('oldTicketNotice');
        if (existingNotice) {
          existingNotice.remove();
        }
        
        // Mostra mensagem na conversa
        if (messagesContainer) {
          oldTicketNotice = document.createElement('div');
          oldTicketNotice.id = 'oldTicketNotice';
          oldTicketNotice.style.cssText = `
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            color: #495057;
            margin: 20px 16px;
            font-size: 14px;
          `;
          
          // Determina a mensagem apropriada
          let title, message;
          if (isClosed) {
            title = 'üîí Esta conversa foi encerrada';
            message = 'O atendimento foi finalizado. Se precisar reabrir a conversa, entre em contato com um administrador.';
          } else {
            title = 'üìã Este √© um hist√≥rico de conversa';
            message = 'Para continuar a conversa, volte ao ticket mais recente com essa pessoa.';
          }
          
          oldTicketNotice.innerHTML = `
            <div style="margin-bottom: 12px;">
              <p style="margin: 0 0 8px 0; font-weight: 600; color: #333;">${title}</p>
              <p style="margin: 0; color: #666;">${message}</p>
            </div>
          `;
          
          // Se for ticket antigo (mas n√£o encerrado), mostra bot√£o para voltar
          if (isOldTicket && !isClosed) {
            const buttonHtml = `
              <button id="backToLatestBtn" style="
                background: #007bff;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 500;
                transition: background 0.2s;
              ">‚Üµ Voltar ao ticket recente</button>
            `;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = buttonHtml;
            oldTicketNotice.appendChild(tempDiv.firstElementChild);
          }
          
          messagesContainer.appendChild(oldTicketNotice);
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
          
          // Adiciona evento ao bot√£o de voltar (se existir)
          const backBtn = document.getElementById('backToLatestBtn');
          if (backBtn) {
            backBtn.addEventListener('click', async () => {
              try {
                const cleanPhone = String(ticket.phone || '').split('@')[0];
                const res = await fetch(`${API_URL}/contacts/${encodeURIComponent(cleanPhone)}/tickets?limit=1&offset=0`, {
                  credentials: 'include',
                  cache: 'no-store'
                });
                if (res.ok) {
                  const latestTickets = await res.json();
                  if (Array.isArray(latestTickets) && latestTickets.length > 0) {
                    const latestTicket = latestTickets[0];
                    await selectTicket(latestTicket);
                    showToast('Voltando ao ticket mais recente...', 'info');
                  }
                }
              } catch (e) {
                showToast('Erro ao buscar o ticket mais recente', 'error');
              }
            });
            backBtn.addEventListener('mouseenter', () => {
              backBtn.style.background = '#0056b3';
            });
            backBtn.addEventListener('mouseleave', () => {
              backBtn.style.background = '#007bff';
            });
          }
        }
      } else {
        const existingNotice = document.getElementById('oldTicketNotice');
        if (existingNotice) existingNotice.remove();
        if (messageInput) {
          messageInput.disabled = false;
          messageInput.placeholder = 'Digite sua mensagem...';
        }
        if (sendBtn) sendBtn.disabled = !messageInput || !messageInput.value.trim();
        if (audioBtn) audioBtn.disabled = false;
        updateConnectionIndicator(isConnected);
      }
    }

    async function loadRemindersForTicket(ticketId) {
      if (!ticketId) return;
      try {
        const response = await fetch(`${API_URL}/tickets/${ticketId}/reminders`, {
          credentials: 'include',
          cache: 'no-store'
        });
        if (!response.ok) throw new Error('Erro ao carregar lembretes');
        currentReminders = await response.json();
        renderReminders();
      } catch (error) {
        currentReminders = [];
        renderReminders();
      }
    }

    function renderReminders() {
      const list = document.getElementById('remindersList');
      if (!list) return;

      const items = Array.isArray(currentReminders) ? currentReminders.filter(r => r.status !== 'canceled') : [];
      if (!items.length) {
        list.innerHTML = '<div style="font-size: 12px; color: #667781;">Nenhum lembrete agendado</div>';
        return;
      }

      list.innerHTML = items.map(rem => {
        const isDone = rem.status === 'done' || rem.status === 'resolvido';
        const dateLabel = formatReminderDate(rem.scheduled_at);
        const noteLabel = rem.note ? escapeHtml(rem.note) : 'Sem observa√ß√£o';
        const messageLabel = rem.message ? escapeHtml(rem.message) : '';
        return `
          <div class="reminder-item" data-reminder-id="${rem.id}">
            <div class="reminder-date">${dateLabel}${isDone ? ' ‚Ä¢ Resolvido' : ''}</div>
            <div class="reminder-note">${noteLabel}</div>
            ${messageLabel ? `<div class="reminder-note">üí¨ ${messageLabel}</div>` : ''}
            <div class="reminder-actions">
              ${!isDone ? `<button class="reminder-btn secondary" data-action="edit">Editar</button>` : ''}
              ${!isDone ? `<button class="reminder-btn secondary" data-action="done">Resolver</button>` : ''}
              ${!isDone ? `<button class="reminder-btn secondary" data-action="cancel">Cancelar</button>` : ''}
            </div>
          </div>
        `;
      }).join('');

      list.querySelectorAll('[data-action]')?.forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const action = e.currentTarget.dataset.action;
          const item = e.currentTarget.closest('.reminder-item');
          const reminderId = item ? item.dataset.reminderId : null;
          const reminder = (currentReminders || []).find(r => String(r.id) === String(reminderId));
          if (!reminderId || !reminder) return;

          if (action === 'edit') {
            openReminderForm(reminder);
          } else if (action === 'cancel') {
            await updateReminder(reminderId, { status: 'canceled' });
          } else if (action === 'done') {
            await updateReminder(reminderId, { status: 'resolvido' });
          }
        });
      });
    }

    function openReminderForm(reminder = null) {
      initReminderPickers();
      const modal = document.getElementById('reminderModal');
      const dateInput = document.getElementById('reminderDate');
      const timeInput = document.getElementById('reminderTime');
      const dateDisplay = document.getElementById('reminderDateDisplay');
      const timeDisplay = document.getElementById('reminderTimeDisplay');
      const noteInput = document.getElementById('reminderNote');
      const messageInput = document.getElementById('reminderMessage');
      if (!modal || !dateInput || !timeInput || !noteInput || !dateDisplay || !timeDisplay || !messageInput) return;

      reminderEditId = reminder ? reminder.id : null;
      if (reminder) {
        const dateValue = toDatetimeLocalValue(reminder.scheduled_at);
        if (dateValue && dateValue.includes('T')) {
          const parts = dateValue.split('T');
          dateInput.value = parts[0] || '';
          timeInput.value = parts[1] || '';
          const [y, m, d] = (parts[0] || '').split('-').map(Number);
          if (y && m && d) {
            reminderPickerState.selectedDate = new Date(y, m - 1, d);
            reminderPickerState.month = new Date(y, m - 1, 1);
            dateDisplay.textContent = formatDateDisplay(reminderPickerState.selectedDate);
          }
          const [hh, mm] = (parts[1] || '').split(':').map(Number);
          if (!Number.isNaN(hh) && !Number.isNaN(mm)) {
            reminderPickerState.selectedHour = hh;
            reminderPickerState.selectedMinute = mm;
            timeDisplay.textContent = formatTimeDisplay(hh, mm);
          }
        }
      } else {
        dateInput.value = '';
        timeInput.value = '';
        reminderPickerState.selectedDate = null;
        reminderPickerState.selectedHour = null;
        reminderPickerState.selectedMinute = null;
        dateDisplay.textContent = 'Selecione a data';
        timeDisplay.textContent = 'Selecione a hora';
      }
      noteInput.value = reminder && reminder.note ? reminder.note : '';
      messageInput.value = reminder && reminder.message ? reminder.message : '';
      modal.classList.add('active');
      renderReminderCalendar();
      initClockPicker();
      dateDisplay.focus();
    }

    function closeReminderForm() {
      const modal = document.getElementById('reminderModal');
      const dateInput = document.getElementById('reminderDate');
      const timeInput = document.getElementById('reminderTime');
      const dateDisplay = document.getElementById('reminderDateDisplay');
      const timeDisplay = document.getElementById('reminderTimeDisplay');
      const noteInput = document.getElementById('reminderNote');
      const messageInput = document.getElementById('reminderMessage');
      reminderEditId = null;
      if (dateInput) dateInput.value = '';
      if (timeInput) timeInput.value = '';
      if (noteInput) noteInput.value = '';
      if (messageInput) messageInput.value = '';
      if (dateDisplay) dateDisplay.textContent = 'Selecione a data';
      if (timeDisplay) timeDisplay.textContent = 'Selecione a hora';
      reminderPickerState.selectedDate = null;
      reminderPickerState.selectedHour = null;
      reminderPickerState.selectedMinute = null;
      toggleReminderPicker(null);
      if (modal) modal.classList.remove('active');
    }

    async function saveReminder() {
      if (!currentTicket) return;
      const dateInput = document.getElementById('reminderDate');
      const timeInput = document.getElementById('reminderTime');
      const noteInput = document.getElementById('reminderNote');
      const messageInput = document.getElementById('reminderMessage');
      const dateValue = dateInput ? dateInput.value : '';
      const timeValue = timeInput ? timeInput.value : '';
      const scheduled_at = dateValue && timeValue ? `${dateValue}T${timeValue}` : '';
      const note = noteInput ? noteInput.value.trim() : '';
      const message = messageInput ? messageInput.value.trim() : '';

      if (!scheduled_at) {
        showToast('Informe data e hora do lembrete', 'warning');
        return;
      }

      try {
        if (reminderEditId) {
          await updateReminder(reminderEditId, { scheduled_at, note, message });
        } else {
          const response = await fetch(`${API_URL}/tickets/${currentTicket.id}/reminders`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ scheduled_at, note, message })
          });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.error || 'Erro ao criar lembrete');
          }
        }

        closeReminderForm();
        await loadRemindersForTicket(currentTicket.id);
        await loadEmptyStateReminders();
        showToast('Lembrete salvo com sucesso', 'success');
      } catch (error) {
        showToast(error.message || 'Erro ao salvar lembrete', 'error');
      }
    }

    async function updateReminder(reminderId, payload) {
      try {
        const response = await fetch(`${API_URL}/reminders/${reminderId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(payload)
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({}));
          throw new Error(error.error || 'Erro ao atualizar lembrete');
        }
        if (currentTicket) {
          await loadRemindersForTicket(currentTicket.id);
        }
        await loadEmptyStateReminders();
      } catch (error) {
        showToast(error.message || 'Erro ao atualizar lembrete', 'error');
      }
    }

    async function checkDueReminders() {
      try {
        const response = await fetch(`${API_URL}/reminders/due`, {
          credentials: 'include',
          cache: 'no-store'
        });
        if (!response.ok) return;
        const due = await response.json();
        if (!Array.isArray(due) || !due.length) return;
        due.forEach(showReminderNotification);
      } catch (_) {}
    }

    function isReminderDue(reminder) {
      const scheduled = parseUtcDateTime(reminder?.scheduled_at);
      if (!scheduled) return false;
      return scheduled.getTime() <= Date.now();
    }

    function prefillMessage(text) {
      const messageInput = document.getElementById('messageInput');
      if (!messageInput || !text) return;
      messageInput.value = text;
      messageInput.focus();
    }

    function buildEmptyReminderHtml(rem, badgeLabel) {
      const name = escapeHtml(rem.contact_name || rem.phone || 'Contato');
      const when = formatReminderDate(rem.scheduled_at);
      const note = rem.note ? escapeHtml(rem.note) : 'Sem observa√ß√£o';
      const message = rem.message ? escapeHtml(rem.message) : '';
      return `
        <div class="empty-reminder-item" data-reminder-id="${rem.id}" data-ticket-id="${rem.ticket_id}">
          <div class="empty-reminder-title">${name}</div>
          <div class="empty-reminder-meta">
            <span>${when}</span>
            <span>‚Ä¢ ${badgeLabel}</span>
          </div>
          <div class="empty-reminder-note">${note}</div>
          ${message ? `<div class="empty-reminder-message">üí¨ ${message}</div>` : ''}
          <div class="empty-reminder-actions">
            <button class="reminder-btn" data-action="open">Abrir conversa</button>
            <button class="reminder-btn secondary" data-action="edit">Editar</button>
            ${badgeLabel === 'Vencido' ? `<button class="reminder-btn secondary" data-action="resolved">Resolver</button>` : ''}
            <button class="reminder-btn secondary" data-action="cancel">Cancelar</button>
          </div>
        </div>
      `;
    }

    function renderEmptyStateReminders({ dueItems = [], futureItems = [] }) {
      const panel = document.getElementById('emptyReminders');
      const list = document.getElementById('emptyRemindersList');
      if (!panel || !list) return;

      const hasDue = Array.isArray(dueItems) && dueItems.length > 0;
      const hasFuture = Array.isArray(futureItems) && futureItems.length > 0;

      if (!hasDue && !hasFuture) {
        panel.style.display = 'none';
        list.innerHTML = '';
        return;
      }

      panel.style.display = 'flex';
      const dueHtml = hasDue
        ? `
          <div class="reminder-list-title">Vencidos</div>
          ${dueItems.map(rem => buildEmptyReminderHtml(rem, 'Vencido')).join('')}
        `
        : '';
      const futureHtml = hasFuture
        ? `
          <div class="reminder-list-title">Agendados</div>
          ${futureItems.map(rem => buildEmptyReminderHtml(rem, 'Agendado')).join('')}
        `
        : '';

      list.innerHTML = `${dueHtml}${futureHtml}`;

      list.querySelectorAll('[data-action]')?.forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const action = e.currentTarget.dataset.action;
          const item = e.currentTarget.closest('.empty-reminder-item');
          if (!item) return;
          const reminderId = item.dataset.reminderId;
          const ticketId = item.dataset.ticketId;
          const allItems = [...(dueItems || []), ...(futureItems || [])];
          const reminder = allItems.find(r => String(r.id) === String(reminderId));
          const reminderMessage = reminder && reminder.message ? reminder.message : '';

          if (action === 'open') {
            await openTicketById(ticketId, reminderMessage);
            return;
          }

          if (action === 'edit' && reminder) {
            openReminderForm(reminder);
            return;
          }

          if (action === 'resolved') {
            await updateReminder(reminderId, { status: 'resolvido' });
            return;
          }

          if (action === 'cancel') {
            await updateReminder(reminderId, { status: 'canceled' });
          }
        });
      });
    }

    async function loadEmptyStateReminders() {
      const panel = document.getElementById('emptyReminders');
      const list = document.getElementById('emptyRemindersList');
      if (!panel || !list) return;

      try {
        const [pendingRes, upcomingRes] = await Promise.all([
          fetch(`${API_URL}/reminders/pending`, {
            credentials: 'include',
            cache: 'no-store'
          }),
          fetch(`${API_URL}/reminders/upcoming?withinHours=720`, {
            credentials: 'include',
            cache: 'no-store'
          })
        ]);

        if (!pendingRes.ok || !upcomingRes.ok) throw new Error('Erro ao carregar lembretes pendentes');
        const pendingData = await pendingRes.json();
        const upcomingData = await upcomingRes.json();

        const pendingItems = Array.isArray(pendingData) ? pendingData : [];
        const upcomingItems = Array.isArray(upcomingData) ? upcomingData : [];

        const byId = new Map();
        pendingItems.forEach(item => { if (item && item.id != null) byId.set(String(item.id), item); });
        upcomingItems.forEach(item => { if (item && item.id != null) byId.set(String(item.id), item); });

        const allItems = Array.from(byId.values()).filter(r => r && r.status === 'scheduled');
        const dueItems = allItems.filter(isReminderDue).sort((a, b) => {
          const da = parseUtcDateTime(a.scheduled_at)?.getTime() || 0;
          const db = parseUtcDateTime(b.scheduled_at)?.getTime() || 0;
          return da - db;
        });
        const futureItems = allItems.filter(r => !isReminderDue(r)).sort((a, b) => {
          const da = parseUtcDateTime(a.scheduled_at)?.getTime() || 0;
          const db = parseUtcDateTime(b.scheduled_at)?.getTime() || 0;
          return da - db;
        });

        renderEmptyStateReminders({ dueItems, futureItems });
      } catch (_) {
        renderEmptyStateReminders({ dueItems: [], futureItems: [] });
      }
    }

    function bindEmptyStateActions() {
      const emptyRemindersRefreshBtn = document.getElementById('emptyRemindersRefreshBtn');
      if (emptyRemindersRefreshBtn && !emptyRemindersRefreshBtn.dataset.bound) {
        emptyRemindersRefreshBtn.dataset.bound = '1';
        emptyRemindersRefreshBtn.addEventListener('click', () => {
          loadEmptyStateReminders();
        });
      }
    }

    async function openTicketById(ticketId, prefillText = '') {
      const id = String(ticketId);
      let ticket = null;
      if (window.latestTickets && Array.isArray(window.latestTickets)) {
        ticket = window.latestTickets.find(t => String(t.id) === id);
      }
      if (!ticket) {
        try {
          const response = await fetch(`${API_URL}/tickets/${id}`, { credentials: 'include' });
          if (response.ok) ticket = await response.json();
        } catch (_) {}
      }
      if (ticket) {
        await selectTicket(ticket);
        if (prefillText) {
          prefillMessage(prefillText);
        }
      }
    }

    async function openTicketFromUrl() {
      let params = null;
      try {
        params = new URLSearchParams(window.location.search || '');
      } catch (_) {
        return;
      }
      const ticketId = params.get('ticketId');
      if (!ticketId) return;
      try {
        await openTicketById(ticketId);
      } catch (_) {
        showToast('N√£o foi poss√≠vel abrir este ticket', 'error');
      }
      params.delete('ticketId');
      params.delete('from');
      const newSearch = params.toString();
      const newUrl = `${window.location.pathname}${newSearch ? `?${newSearch}` : ''}${window.location.hash || ''}`;
      try { window.history.replaceState({}, '', newUrl); } catch (_) {}
    }

    function showReminderNotification(reminder) {
      const toast = document.createElement('div');
      toast.className = 'custom-toast';
      const name = reminder.contact_name || reminder.phone || 'Contato';
      const when = formatReminderDate(reminder.scheduled_at);
      const note = reminder.note ? escapeHtml(reminder.note) : 'Sem observa√ß√£o';
      const message = reminder.message ? escapeHtml(reminder.message) : '';
      toast.innerHTML = `
        <div class="custom-toast-icon">‚è∞</div>
        <div class="custom-toast-message">
          <div style="font-weight: 600; margin-bottom: 4px;">Lembrete: ${name}</div>
          <div style="font-size: 12px; color: #667781;">${when}</div>
          <div style="font-size: 12px; color: #374151; margin-top: 6px;">${note}</div>
          ${message ? `<div style="font-size: 12px; color: #374151; margin-top: 6px;">üí¨ ${message}</div>` : ''}
          <button class="reminder-btn" data-action="open" style="margin-top: 8px;">Abrir conversa</button>
        </div>
        <button class="custom-toast-close" data-role="close-toast">√ó</button>
      `;

      document.body.appendChild(toast);

      const openBtn = toast.querySelector('[data-action="open"]');
      if (openBtn) {
        openBtn.addEventListener('click', async () => {
          await openTicketById(reminder.ticket_id, reminder.message || '');
          toast.remove();
        });
      }

      setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => toast.remove(), 300);
      }, 7000);
    }

    async function renderTicketHistory(phone, activeTicketId, options = {}) {
      const container = document.getElementById('ticketHistory');
      if (!container) return;

      // Avoid spamming when the user clicks very fast on history items.
      // This keeps the UX responsive while preventing unnecessary API bursts.
      if (!renderTicketHistory._navState) {
        renderTicketHistory._navState = { inFlight: false, lastClickAt: 0, cachedTickets: null, cacheTime: 0, lastPhone: null };
      }

      const cleanPhone = String(phone || '').split('@')[0];
      if (!cleanPhone) {
        container.style.display = 'none';
        container.innerHTML = '';
        return;
      }

      const nav = renderTicketHistory._navState;
      const now = Date.now();
      let tickets = null;
      
      // Check cache: reuse tickets list for 10 seconds to avoid refetch on rapid history opens
      if (nav.lastPhone === cleanPhone && nav.cachedTickets && nav.cacheTime && (now - nav.cacheTime) < 10000) {
        tickets = nav.cachedTickets;
      } else {
        const res = await fetch(`${API_URL}/contacts/${encodeURIComponent(cleanPhone)}/tickets?limit=20&offset=0`, {
          credentials: 'include',
          cache: 'no-store',
          signal: options.signal
        });
        if (!res.ok) {
          container.style.display = 'none';
          container.innerHTML = '';
          return;
        }
        tickets = await res.json();
        nav.cachedTickets = tickets;
        nav.cacheTime = now;
        nav.lastPhone = cleanPhone;
      }
      
      if (!Array.isArray(tickets) || tickets.length <= 1) {
        container.style.display = 'none';
        container.innerHTML = '';
        return;
      }

      const items = tickets
        .filter(t => t && t.id)
        .slice(0, 8)
        .map(t => {
          const isActive = String(t.id) === String(activeTicketId);
          const label = isActive ? `#${t.id} (atual)` : `#${t.id}`;
          const statusLabel = getStatusLabel(t.status);
          return `<a data-ticket-id="${t.id}" ${isActive ? 'aria-current="true"' : ''}>${label} <span class="history-status status-${t.status}">${statusLabel}</span></a>`;
        })
        .join(' ¬∑ ');

      container.innerHTML = `Hist√≥rico: ${items}`;
      container.style.display = 'flex';

      container.querySelectorAll('a[data-ticket-id]').forEach(a => {
        a.addEventListener('click', async () => {
          const id = a.getAttribute('data-ticket-id');
          if (!id) return;

          const nav = renderTicketHistory._navState;
          const now = Date.now();
          if (nav.inFlight) return;
          // Debounce ultra-fast repeated clicks (double-click / rage-click)
          if (now - nav.lastClickAt < 900) return;
          nav.lastClickAt = now;
          nav.inFlight = true;

          // Temporarily disable clicks in the history bar
          try {
            container.style.pointerEvents = 'none';
            container.style.opacity = '0.85';
          } catch (_) {}

          const selected = tickets.find(t => String(t.id) === String(id));
          if (!selected) {
            nav.inFlight = false;
            try {
              container.style.pointerEvents = '';
              container.style.opacity = '';
            } catch (_) {}
            return;
          }

          try {
            const isLatest = Array.isArray(tickets) && tickets.length > 0 && String(tickets[0].id) === String(selected.id);
            selected.isLatestTicket = isLatest;
            await selectTicket(selected);
            showToast('Abrindo hist√≥rico do contato', 'info');
          } finally {
            nav.inFlight = false;
            try {
              container.style.pointerEvents = '';
              container.style.opacity = '';
            } catch (_) {}
          }
        });
      });
    }

    // Atribui ticket a vendedor (admin ou vendedor)
    async function assignTicketToSeller() {
      if (!currentTicket) return;
      
      const sellerSelect = document.getElementById('sellerSelect');
      const sellerId = sellerSelect.value;
      const targetSellerId = sellerId ? parseInt(sellerId, 10) : null;
      const previousSellerId = currentTicket.seller_id ? String(currentTicket.seller_id) : '';

      if (String(targetSellerId || '') === previousSellerId) {
        return;
      }

      if (userType === 'seller') {
        const currentUserId = parseInt(userId, 10);
        if (!targetSellerId || targetSellerId === currentUserId) {
          showToast('Selecione outro vendedor', 'error');
          sellerSelect.value = previousSellerId;
          updateCustomSelect('sellerSelect');
          return;
        }
      }

      const targetSeller = sellers.find(s => s.id == targetSellerId);
      const safeSellerName = targetSeller ? escapeHtml(targetSeller.name) : 'este vendedor';
      let confirmHeader = '‚ö†Ô∏è Confirmar atribui√ß√£o';
      let confirmMessage = 'Confirmar atribui√ß√£o deste ticket?';
      let confirmText = 'Confirmar';

      if (userType === 'admin') {
        confirmHeader = '‚ö†Ô∏è Alterar atribui√ß√£o';
        confirmMessage = targetSellerId
          ? `Confirmar atribuir para <strong>${safeSellerName}</strong>?`
          : 'Confirmar remover atribui√ß√£o do ticket?';
      } else {
        confirmHeader = 'üîÑ Transferir ticket';
        confirmMessage = `Confirmar transfer√™ncia para <strong>${safeSellerName}</strong>?`;
      }

      const confirmed = await confirmWithModal({
        header: confirmHeader,
        message: confirmMessage,
        confirmText,
        cancelText: 'Cancelar'
      });

      if (!confirmed) {
        sellerSelect.value = previousSellerId;
        updateCustomSelect('sellerSelect');
        return;
      }
      
      try {
        const response = await fetch(`${API_URL}/tickets/${currentTicket.id}/assign`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ sellerId: targetSellerId || null })
        });

        if (response.ok) {
          // Atualiza o ticket atual
          currentTicket.seller_id = targetSellerId;
          const seller = sellers.find(s => s.id == targetSellerId);
          currentTicket.seller_name = seller ? seller.name : null;
          
          // Recarrega a lista de tickets (topo)
          await loadTickets({ refreshTop: true });

          if (userType === 'seller') {
            const currentUserId = parseInt(userId, 10);
            if (targetSellerId !== currentUserId) {
              currentTicket = null;
              document.getElementById('chatArea').style.display = 'none';
              document.getElementById('emptyState').style.display = 'flex';
            }
          }
        } else {
          sellerSelect.value = previousSellerId;
          updateCustomSelect('sellerSelect');
          showToast('Erro ao atribuir vendedor', 'error');
        }
      } catch (error) {
        sellerSelect.value = previousSellerId;
        updateCustomSelect('sellerSelect');
        showToast('Erro ao atribuir vendedor', 'error');
      }
    }

    // Armazena √∫ltima contagem de mensagens para detectar novas
    let lastMessageCount = {};
    let lastMessageTimestamp = {}; // Armazena timestamp da √∫ltima mensagem por ticket
    let lastMessageId = {}; // Cursor por id para evitar perda de mensagens no mesmo segundo
    let isLoadingMessages = false;
    let loadingMessagesForTicketId = null;
    let hasLoadedMessages = {};
    let pendingMessageRefresh = false;
    let isSelectingTicket = false;

    // Carrega mensagens
    async function loadMessages(ticketId, isAutoRefresh = false, loadOlder = false) {
      if (isLoadingMessages) {
        if (!isAutoRefresh && loadingMessagesForTicketId && String(loadingMessagesForTicketId) !== String(ticketId)) {
          try { if (messagesAbortController) messagesAbortController.abort(); } catch (_) {}
          isLoadingMessages = false;
          pendingMessageRefresh = false;
        } else {
          if (isAutoRefresh) pendingMessageRefresh = true;
          return;
        }
      }
      isLoadingMessages = true;
      loadingMessagesForTicketId = ticketId;
      try {
        const tokenAtStart = ticketSelectionToken;
        if (currentTicket && String(currentTicket.id) !== String(ticketId)) {
          isLoadingMessages = false;
          return;
        }
        const abortSignal = messagesAbortController ? messagesAbortController.signal : undefined;
        const container = document.getElementById('messagesContainer');
        
        const shouldScroll = container.scrollTop + container.clientHeight >= container.scrollHeight - 100;
        const isTopLoading = loadOlder;
        const prevScrollHeight = container.scrollHeight;
        const prevScrollTop = container.scrollTop;

        const fetchFn = (typeof smartJson === 'function') ? smartJson : async (u, o) => {
          const r = await fetch(u, o);
          if (!r.ok) throw new Error(`HTTP ${r.status}`);
          return r.json();
        };

        // Se for auto-refresh, tenta carregar apenas novas mensagens
        let messages = [];
        if (isAutoRefresh && lastMessageTimestamp[ticketId]) {
          const since = encodeURIComponent(String(lastMessageTimestamp[ticketId]));
          const lastId = lastMessageId[ticketId] ? `&lastId=${encodeURIComponent(String(lastMessageId[ticketId]))}` : '';
          const sinceUrl = `${API_URL}/tickets/${ticketId}/messages/since/${since}${lastId ? `?${lastId.slice(1)}` : ''}`;
          messages = await fetchFn(sinceUrl, {
            credentials: 'include',
            cache: 'no-store',
            maxRetries: 1,
            signal: abortSignal,
          });
          if (!messages.length) {
            isLoadingMessages = false;
            if (pendingMessageRefresh) {
              pendingMessageRefresh = false;
              loadMessages(ticketId, true);
            }
            return;
          }
        } else if (loadOlder) {
          const before = earliestMessageTimestamp[ticketId];
          if (!before) {
            isLoadingMessages = false;
            if (pendingMessageRefresh) {
              pendingMessageRefresh = false;
              loadMessages(ticketId, true);
            }
            return;
          }
          messages = await fetchFn(`${API_URL}/tickets/${ticketId}/messages?limit=${MESSAGES_PAGE_SIZE}&before=${encodeURIComponent(before)}`, {
            credentials: 'include',
            cache: 'no-store',
            maxRetries: 1,
            signal: abortSignal,
          });
          if (!messages.length) {
            allHistoryLoaded[ticketId] = true;
            isLoadingMessages = false;
            if (pendingMessageRefresh) {
              pendingMessageRefresh = false;
              loadMessages(ticketId, true);
            }
            return;
          }
        } else {
          messages = await fetchFn(`${API_URL}/tickets/${ticketId}/messages?limit=${MESSAGES_PAGE_SIZE}`, {
            credentials: 'include',
            cache: 'no-store',
            maxRetries: 1,
            signal: abortSignal,
          });
          container.innerHTML = '';
          lastMessageCount[ticketId] = 0;
          hasLoadedMessages[ticketId] = true;
          allHistoryLoaded[ticketId] = false;
          earliestMessageTimestamp[ticketId] = null;
          lastMessageId[ticketId] = 0;
        }

        if (tokenAtStart !== ticketSelectionToken || (currentTicket && String(currentTicket.id) !== String(ticketId))) {
          isLoadingMessages = false;
          return;
        }

        let newCursor = lastMessageTimestamp[ticketId] || null;

        const cursorOf = (m) => (m && (m.updated_at || m.created_at)) || null;

        const fragment = document.createDocumentFragment();

        messages.forEach(msg => {
            // Upsert message element (avoid duplicates; allow updates like audio media_url)
            const elId = `msg-${msg.id}`;
            let div = document.getElementById(elId);
            const isNewEl = !div;
            if (!div) {
              div = document.createElement('div');
              div.id = elId;
            }

            const isSystem = (msg.sender === 'system') || (msg.message_type === 'system');
            div.className = isSystem ? 'message message-system' : `message message-${msg.sender}`;
            
            let contentHtml = '';

            if (isSystem) {
              // Mensagem de sistema (marcador/aviso no meio do chat)
              contentHtml = `
                <div>${msg.content}</div>
                <div class="message-time">${formatMessageTime(msg.created_at)}</div>
              `;
            }
            
            // Se for imagem, exibe a imagem
            else if (msg.message_type === 'image' && msg.media_url) {
              const imageId = `img-${msg.id}`;
              const contentDiv = msg.content !== '[Imagem]' ? `<div>${msg.content}</div>` : '';
              const isBase64 = msg.media_url && msg.media_url.startsWith('data:');
              contentHtml = `
                ${msg.reply_to_id ? generateQuoteBlock(msg) : ''}
                ${msg.sender === 'agent' && msg.sender_name ? `<strong>${msg.sender_name}:</strong> ` : ''}
                ${contentDiv}
                <div class="image-loading" id="loading-${imageId}">
                  <div class="image-loading-spinner"></div>
                  <span>Carregando imagem...</span>
                </div>
                <img 
                  id="${imageId}" 
                  data-src="${msg.media_url}" 
                  data-loading-id="loading-${imageId}"
                  data-error-label="imagem"
                  data-error-src="${isBase64 ? 'base64 data' : msg.media_url}"
                  class="message-image lazy-media" 
                  alt="Imagem" 
                  style="cursor: pointer; user-select: none; -webkit-user-select: none;"
                >
                <div class="message-time">${formatMessageTime(msg.created_at)}</div>
              `;
            } else if (msg.message_type === 'audio' && msg.media_url) {
              // Se for √°udio, exibe o player customizado ou loading
              const audioId = `audio-${msg.id}`;
              if (msg.media_url === 'loading') {
                contentHtml = `
                  ${msg.reply_to_id ? generateQuoteBlock(msg) : ''}
                  ${msg.sender === 'agent' && msg.sender_name ? `<strong>${msg.sender_name}:</strong> ` : ''}
                  <div class="audio-loading">
                    <div class="audio-loading-spinner"></div>
                    <span>Processando √°udio...</span>
                  </div>
                  <div class="message-time">${formatMessageTime(msg.created_at)}</div>
                `;
              } else {
                contentHtml = `
                  ${msg.reply_to_id ? generateQuoteBlock(msg) : ''}
                  ${msg.sender === 'agent' && msg.sender_name ? `<strong>${msg.sender_name}:</strong> ` : ''}
                  <div class="audio-player">
                    <button class="audio-play-btn" data-audio-id="${audioId}" id="btn-${audioId}">
                      ‚ñ∂
                    </button>
                    <div class="audio-info">
                      <div class="audio-title">Mensagem de √°udio</div>
                      <div class="audio-progress" data-audio-id="${audioId}">
                        <div class="audio-progress-bar" id="progress-${audioId}"></div>
                      </div>
                      <div class="audio-time">
                        <span id="current-${audioId}">0:00</span>
                        <span id="duration-${audioId}">0:00</span>
                      </div>
                    </div>
                    <audio id="${audioId}" class="lazy-media" style="display:none;" preload="metadata" data-src="${msg.media_url}"></audio>
                  </div>
                  <div class="message-time">${formatMessageTime(msg.created_at)}</div>
                `;
              }
            } else if (msg.message_type === 'video' && msg.media_url) {
              // Se for v√≠deo, exibe o player ou loading
              const videoId = `video-${msg.id}`;
              const contentDiv = msg.content !== '[V√≠deo]' ? `<div>${msg.content}</div>` : '';
              if (msg.media_url === 'loading') {
                contentHtml = `
                  ${msg.reply_to_id ? generateQuoteBlock(msg) : ''}
                  ${msg.sender === 'agent' && msg.sender_name ? `<strong>${msg.sender_name}:</strong> ` : ''}
                  <div>üé• Processando v√≠deo...</div>
                  <div class="message-time">${formatMessageTime(msg.created_at)}</div>
                `;
              } else {
                contentHtml = `
                  ${msg.reply_to_id ? generateQuoteBlock(msg) : ''}
                  ${msg.sender === 'agent' && msg.sender_name ? `<strong>${msg.sender_name}:</strong> ` : ''}
                  ${contentDiv}
                  <video id="${videoId}" controls class="lazy-media" data-src="${msg.media_url}" style="max-width: 260px; margin-top: 8px; border-radius: 8px;">
                    <source data-src="${msg.media_url}" type="video/mp4">
                    <source data-src="${msg.media_url}" type="video/webm">
                    Seu navegador n√£o suporta o elemento de v√≠deo.
                  </video>
                  <div class="message-time">${formatMessageTime(msg.created_at)}</div>
                `;
              }
            } else if (msg.message_type === 'sticker' && msg.media_url) {
              const stickerId = `sticker-${msg.id}`;
              const isBase64 = msg.media_url && msg.media_url.startsWith('data:');
              contentHtml = `
                ${msg.reply_to_id ? generateQuoteBlock(msg) : ''}
                ${msg.sender === 'agent' && msg.sender_name ? `<strong>${msg.sender_name}:</strong> ` : ''}
                <div class="image-loading" id="loading-${stickerId}">
                  <div class="image-loading-spinner"></div>
                  <span>Carregando figurinha...</span>
                </div>
                <img 
                  id="${stickerId}" 
                  data-src="${msg.media_url}" 
                  data-loading-id="loading-${stickerId}"
                  data-error-label="figurinha"
                  data-error-src="${isBase64 ? 'base64 data' : msg.media_url}"
                  class="message-sticker lazy-media" 
                  alt="Figurinha" 
                >
                <div class="message-time">${formatMessageTime(msg.created_at)}</div>
              `;
            } else {
              // Mensagem de texto normal
              contentHtml = `
                ${msg.reply_to_id ? generateQuoteBlock(msg) : ''}
                ${msg.sender === 'agent' && msg.sender_name ? `<strong>${msg.sender_name}:</strong> ` : ''}
                <div>${msg.content}</div>
                <div class="message-time">${formatMessageTime(msg.created_at)}</div>
              `;
            }
            
            div.innerHTML = contentHtml;

            // Carrega dados das mensagens citadas
            if (msg.reply_to_id) {
              loadQuoteData(msg.reply_to_id);
            }

            if (isNewEl) {
              fragment.appendChild(div);
            }

            const c = cursorOf(msg);
            if (c && (!newCursor || c > newCursor)) newCursor = c;
        });

        if (fragment.childNodes.length > 0) {
          if (isTopLoading) {
            container.insertBefore(fragment, container.firstChild);
          } else {
            container.appendChild(fragment);
          }
        }

        // Atualiza timestamp da √∫ltima mensagem
        if (messages.length > 0) {
          // Use updated_at when present to catch media processing updates
          if (newCursor) lastMessageTimestamp[ticketId] = newCursor;
          const maxId = messages.reduce((acc, m) => (m && m.id && m.id > acc ? m.id : acc), lastMessageId[ticketId] || 0);
          if (maxId) lastMessageId[ticketId] = maxId;
          lastMessageCount[ticketId] = (lastMessageCount[ticketId] || 0) + messages.length;

          const oldest = messages[0]?.created_at;
          if (oldest && (!earliestMessageTimestamp[ticketId] || oldest < earliestMessageTimestamp[ticketId])) {
            earliestMessageTimestamp[ticketId] = oldest;
          }
        }

        // Inicializa players de √°udio rec√©m-inseridos
        initAudioPlayers(container);

        // Inicializa lazy loading de m√≠dias
        initLazyMedia(container);

        // Inicializa listeners de reply (duplo clique)
        initMessageReplyListeners(container);

        // Ajusta scroll quando carregando mensagens antigas
        if (isTopLoading) {
          const newScrollHeight = container.scrollHeight;
          container.scrollTop = newScrollHeight - prevScrollHeight + prevScrollTop;
        }

        // Scroll para o final apenas se o usu√°rio estava no final
        if ((shouldScroll || !isAutoRefresh) && !isTopLoading) {
          setTimeout(() => {
            container.scrollTop = container.scrollHeight;
          }, 0);
        }
      } catch (error) {
        // Erro ao carregar mensagens
      } finally {
        isLoadingMessages = false;
        loadingMessagesForTicketId = null;
        if (pendingMessageRefresh) {
          pendingMessageRefresh = false;
          loadMessages(ticketId, true);
        }
      }
    }

    function initMessageInfiniteScroll(container) {
      if (!container || container.dataset.scrollInit === '1') return;
      container.dataset.scrollInit = '1';
      container.addEventListener('scroll', async () => {
        if (!currentTicket) return;
        const ticketId = currentTicket.id;
        if (container.scrollTop > 120) return;
        if (isLoadingMessages) return;
        if (allHistoryLoaded[ticketId]) return;
        if (!earliestMessageTimestamp[ticketId]) return;

        isLoadingOlder[ticketId] = true;
        try {
          await loadMessages(ticketId, false, true);
        } finally {
          isLoadingOlder[ticketId] = false;
        }
      });
    }

    function initLazyMedia(container) {
      if (!container) return;

      const targets = container.querySelectorAll('.lazy-media');
      if (!('IntersectionObserver' in window)) {
        targets.forEach(el => loadMediaEl(el));
        return;
      }

      if (!lazyMediaObserver) {
        lazyMediaObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (!entry.isIntersecting) return;
            loadMediaEl(entry.target);
            lazyMediaObserver.unobserve(entry.target);
          });
        }, { root: container, rootMargin: '200px' });
      }

      targets.forEach(el => {
        if (el.dataset.loaded === '1') return;
        lazyMediaObserver.observe(el);
      });
    }

    function bindImageHandlers(el) {
      if (!el || el.dataset.handlersBound === '1') return;
      el.dataset.handlersBound = '1';

      const loadingId = el.dataset.loadingId;
      const errorLabel = el.dataset.errorLabel || 'm√≠dia';
      const errorSrc = el.dataset.errorSrc || el.dataset.src || 'desconhecido';

      el.addEventListener('load', () => {
        const loadingEl = loadingId ? document.getElementById(loadingId) : null;
        el.classList.add('loaded');
        if (loadingEl) loadingEl.style.display = 'none';
        const msgContainer = document.getElementById('messagesContainer');
        if (msgContainer) msgContainer.scrollTop = msgContainer.scrollHeight;
      });

      el.addEventListener('error', () => {
        const loadingEl = loadingId ? document.getElementById(loadingId) : null;
        if (loadingEl) {
          loadingEl.innerHTML = `<span style=color:#ff6b6b>‚ùå Erro ao carregar ${errorLabel}</span>`;
        }
        console.error(`Erro ao carregar ${errorLabel} - mediaUrl:`, errorSrc);
      });
    }

    function loadMediaEl(el) {
      if (!el || el.dataset.loaded === '1') return;
      el.dataset.loaded = '1';

      if (el.tagName === 'IMG') {
        bindImageHandlers(el);
        const src = el.dataset.src;
        if (src) el.src = src;
        return;
      }

      if (el.tagName === 'VIDEO') {
        const sources = el.querySelectorAll('source[data-src]');
        sources.forEach(s => {
          if (!s.src) s.src = s.dataset.src;
        });
        try { el.load(); } catch (e) {}
        return;
      }

      if (el.tagName === 'AUDIO') {
        ensureAudioSource(el.id);
      }
    }

    // Envia mensagem
    async function sendMessage() {
      if (!currentTicket) return;
      
      // Verifica se √© um ticket antigo (n√£o √© o mais recente) ou se foi encerrado
      const isOldTicket = currentTicket.isLatestTicket === false;
      const isClosed = currentTicket.status === 'resolvido' || currentTicket.status === 'encerrado';
      
      if (isOldTicket && !isClosed) {
        showToast('‚ùå N√£o √© poss√≠vel enviar mensagens em tickets antigos. Volte ao ticket atual para continuar a conversa.', 'error');
        return;
      }
      
      if (isClosed) {
        showToast('‚ùå N√£o √© poss√≠vel enviar mensagens em conversa encerrada.', 'error');
        return;
      }
      
      if (!isConnected) {
        showToast('WhatsApp desconectado. Por favor, aguarde a reconex√£o.', 'warning');
        return;
      }

      const input = document.getElementById('messageInput');
      const message = input.value.trim();

      if (!message) return;

      try {
        const payload = { message };
        if (currentReplyTo) {
          payload.reply_to_id = currentReplyTo;
        }

        const response = await fetch(`${API_URL}/tickets/${currentTicket.id}/send`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },          credentials: 'include',          body: JSON.stringify(payload)
        });

        if (response.ok) {
          input.value = '';
          clearReply();
          // Atualiza imediatamente as mensagens ap√≥s enviar
          await loadMessages(currentTicket.id, true);
          await loadTickets({ refreshTop: true });
          try { updateHeaderFromTicket(currentTicket); } catch (e) {}
        } else {
          const error = await response.json();
          showToast(error.error || 'Erro ao enviar mensagem', 'error');
        }
      } catch (error) {
        showToast('Erro ao enviar mensagem. Verifique a conex√£o.', 'error');
      }
    }

    // Fun√ß√£o para enviar √°udio gravado
    async function sendRecordedAudio() {
      if (!currentTicket || !window.recordedAudioBlob) {
        showToast('Erro ao enviar √°udio', 'error');
        return;
      }

      // Verifica se √© um ticket antigo (n√£o √© o mais recente)
      if (currentTicket.isLatestTicket === false) {
        showToast('‚ùå N√£o √© poss√≠vel enviar √°udio em tickets antigos. Volte ao ticket atual para continuar a conversa.', 'error');
        return;
      }

      if (!isConnected) {
        showToast('WhatsApp desconectado. Por favor, aguarde a reconex√£o.', 'warning');
        return;
      }

      try {
        const formData = new FormData();
        formData.append('audio', window.recordedAudioBlob, 'recorded-audio.webm');
        
        if (currentReplyTo) {
          formData.append('reply_to_id', currentReplyTo);
        }

        const response = await fetch(`${API_URL}/tickets/${currentTicket.id}/send-audio`, {
          method: 'POST',
          credentials: 'include',
          body: formData
        });

        if (response.ok) {
          showToast('√Åudio enviado com sucesso!', 'info');
          clearReply();
          cancelRecording();
          // Atualiza imediatamente as mensagens ap√≥s enviar
          await loadMessages(currentTicket.id, true);
          await loadTickets({ refreshTop: true });
          try { updateHeaderFromTicket(currentTicket); } catch (e) {}
        } else {
          const error = await response.json();
          showToast(error.error || 'Erro ao enviar √°udio', 'error');
        }
      } catch (error) {
        console.error('Erro ao enviar √°udio gravado:', error);
        showToast('Erro ao enviar √°udio. Verifique a conex√£o.', 'error');
      }
    }

    // ===== GRAVA√á√ÉO DE √ÅUDIO INTELIGENTE (DESKTOP + MOBILE) =====
    let mediaRecorder = null;
    let audioChunks = [];
    let recordingStartTime = null;
    let recordingTimerInterval = null;
    let isRecording = false;
    let isMobile = false;
    let holdTimeout = null;
    let recordBtn = null;

    // Detecta se √© mobile
    function detectMobile() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // Inicializa event listeners do bot√£o de √°udio
    function initAudioButton() {
      recordBtn = document.getElementById('recordBtn');
      if (!recordBtn) return;

      // Microfone normalmente s√≥ funciona em contexto seguro (HTTPS), exceto localhost.
      // Se estiver acessando por IP via HTTP, o navegador bloqueia getUserMedia.
      try {
        const host = String(window.location.hostname || '').toLowerCase();
        const isLocal = host === 'localhost' || host === '127.0.0.1' || host === '::1';
        if (!window.isSecureContext && !isLocal) {
          recordBtn.disabled = true;
          recordBtn.title = 'Grava√ß√£o de √°udio requer HTTPS (ou localhost). Abra o sistema em https://SEU_IP:PORTA (ex.: 3443).';
          recordBtn.addEventListener('click', (e) => {
            e.preventDefault();
            showToast('‚ö†Ô∏è O navegador bloqueia microfone em HTTP por IP. Acesse o sistema via HTTPS (ou use localhost) para enviar √°udio.', 'warning');
          });
          return;
        }
      } catch (_) {}

      isMobile = detectMobile();

      if (isMobile) {
        // Mobile: press-and-hold
        recordBtn.addEventListener('touchstart', handleMobileStart);
        recordBtn.addEventListener('touchend', handleMobileEnd);
        recordBtn.addEventListener('touchcancel', handleMobileCancel);
      } else {
        // Desktop: toggle clique
        recordBtn.addEventListener('click', handleDesktopClick);
      }
    }

    // Desktop: alterna entre gravar e parar
    function handleDesktopClick(e) {
      e.preventDefault();
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    }

    // Mobile: inicia ao pressionar
    function handleMobileStart(e) {
      e.preventDefault();
      holdTimeout = setTimeout(() => {
        startRecording();
      }, 100); // Pequeno delay para evitar cliques acidentais
    }

    // Mobile: para ao soltar
    function handleMobileEnd(e) {
      e.preventDefault();
      clearTimeout(holdTimeout);
      if (isRecording) {
        stopRecording();
      }
    }

    // Mobile: cancelar se der erro
    function handleMobileCancel(e) {
      e.preventDefault();
      clearTimeout(holdTimeout);
      if (isRecording) {
        cancelRecording();
      }
    }

    async function startRecording() {
      if (!currentTicket) {
        showToast('Selecione um ticket primeiro', 'warning');
        return;
      }

      if (isRecording) return;

      // Verifica se a API de microfone est√° dispon√≠vel
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showToast('Seu navegador n√£o suporta grava√ß√£o de √°udio. Use Chrome, Firefox ou Edge atualizado.', 'error');
        return;
      }

      try {
        isRecording = true;
        // Solicita permiss√£o do microfone
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        // Inicia grava√ß√£o
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };

        mediaRecorder.start();
        recordingStartTime = Date.now();

        // Mostra modal
        document.getElementById('recordingModal').classList.add('active');

        // Atualiza bot√£o para indicar grava√ß√£o ativa
        if (recordBtn) recordBtn.style.opacity = '0.6';

        // Timer de grava√ß√£o
        recordingTimerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          document.getElementById('recordingTimer').textContent = 
            `Gravando ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }, 100);
      } catch (error) {
        console.error('Erro ao acessar microfone:', error);
        isRecording = false;
        if (recordBtn) recordBtn.style.opacity = '1';
        
        let errorMsg = 'Erro ao acessar o microfone. Verifique as permiss√µes.';
        if (error.name === 'SecurityError') {
          errorMsg = 'O navegador bloqueou o microfone por seguran√ßa. Use HTTPS (ou localhost) para gravar/enviar √°udio.';
        } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          errorMsg = 'Permiss√£o negada. Clique em "Permitir" quando o navegador pedir.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          errorMsg = 'Nenhum microfone conectado ao dispositivo.';
        } else if (error.name === 'NotSupportedError') {
          errorMsg = 'Seu navegador n√£o suporta grava√ß√£o de √°udio. Use Chrome, Firefox ou Edge.';
        } else if (error.message) {
          errorMsg = `Erro: ${error.message}`;
        }
        showToast(errorMsg, 'error');
      }
    }

    function stopRecording() {
      if (!mediaRecorder || !isRecording) return;

      isRecording = false;
      
      // Calcula dura√ß√£o ANTES de resetar recordingStartTime
      const recordingEndTime = Date.now();
      const recordingDuration = (recordingEndTime - recordingStartTime) / 1000;
      
      mediaRecorder.stop();
      recordingStartTime = null;
      clearInterval(recordingTimerInterval);

      // Volta bot√£o ao normal
      if (recordBtn) recordBtn.style.opacity = '1';

      mediaRecorder.onstop = () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });

        // Para o stream de √°udio
        mediaRecorder.stream.getTracks().forEach(track => track.stop());

        // Fecha modal
        document.getElementById('recordingModal').classList.remove('active');
        document.getElementById('recordingTimer').textContent = 'Gravando 00:00';

        // Valida dura√ß√£o m√≠nima (1 segundo)
        if (recordingDuration < 1.0) {
          showToast('√Åudio muito curto. Grave por pelo menos 1 segundo.', 'warning');
          cancelRecording();
          return;
        }

        // Armazena o blob e envia automaticamente
        window.recordedAudioBlob = audioBlob;
        
        // Envia √°udio automaticamente
        sendRecordedAudio();
      };
    }

    function cancelRecording() {
      if (!mediaRecorder) return;

      isRecording = false;
      mediaRecorder.stop();
      recordingStartTime = null;
      clearInterval(recordingTimerInterval);
      clearTimeout(holdTimeout);

      // Para o stream de √°udio
      mediaRecorder.stream.getTracks().forEach(track => track.stop());

      // Fecha modal
      document.getElementById('recordingModal').classList.remove('active');
      document.getElementById('recordingTimer').textContent = 'Gravando 00:00';

      // Volta bot√£o ao normal
      if (recordBtn) recordBtn.style.opacity = '1';

      window.recordedAudioBlob = null;
    }

    function initUiBindings() {
      const logoutBtn = document.getElementById('logoutBtn');
      if (logoutBtn) logoutBtn.addEventListener('click', logout);

      const manageBtn = document.getElementById('manageSellersBtn');
      if (manageBtn) {
        manageBtn.addEventListener('click', () => {
          if (typeof navigateTo === 'function') navigateTo('/admin-sellers');
          else window.location.href = '/admin-sellers';
        });
      }

      const backBtn = document.getElementById('backToTicketsBtn');
      if (backBtn) backBtn.addEventListener('click', backToTicketList);

      const closeConversationBtn = document.getElementById('closeConversationBtn');
      if (closeConversationBtn) closeConversationBtn.addEventListener('click', closeCurrentConversation);

      const sellerSelect = document.getElementById('sellerSelect');
      if (sellerSelect) sellerSelect.addEventListener('change', assignTicketToSeller);

      const replyCloseBtn = document.getElementById('replyCloseBtn');
      if (replyCloseBtn) replyCloseBtn.addEventListener('click', clearReply);

      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) sendBtn.addEventListener('click', sendMessage);

      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        messageInput.addEventListener('keydown', handleEnter);
      }

      const openReminderBtn = document.getElementById('openReminderBtn');
      if (openReminderBtn) openReminderBtn.addEventListener('click', () => openReminderForm());

      const reminderSaveBtn = document.getElementById('reminderSaveBtn');
      if (reminderSaveBtn) reminderSaveBtn.addEventListener('click', saveReminder);

      const reminderCancelBtn = document.getElementById('reminderCancelBtn');
      if (reminderCancelBtn) reminderCancelBtn.addEventListener('click', closeReminderForm);

      const reminderCloseBtn = document.getElementById('reminderModalClose');
      if (reminderCloseBtn) reminderCloseBtn.addEventListener('click', closeReminderForm);

      const reminderModal = document.getElementById('reminderModal');
      if (reminderModal) {
        reminderModal.addEventListener('click', (e) => {
          if (e.target === reminderModal) closeReminderForm();
        });
      }

      const toggleClosed = document.getElementById('toggleClosedTickets');
      if (toggleClosed) {
        toggleClosed.addEventListener('change', async () => {
          showClosedTickets = !!toggleClosed.checked;
          await loadTickets({ append: false, refreshTop: false });
        });
      }

      initReminderPickers();

      const lightbox = document.getElementById('imageLightbox');
      if (lightbox) lightbox.addEventListener('click', closeLightbox);

      const messagesContainer = document.getElementById('messagesContainer');
      if (messagesContainer) {
        messagesContainer.addEventListener('click', (event) => {
          const progress = event.target.closest('.audio-progress');
          if (progress && progress.dataset.audioId) {
            seekAudio(event, progress.dataset.audioId);
          }
        });
      }

      document.addEventListener('click', (event) => {
        const closeBtn = event.target.closest('[data-role="close-toast"]');
        if (closeBtn && closeBtn.parentElement) {
          closeBtn.parentElement.remove();
        }
      });
    }

    // Inicializa quando documento carrega
    document.addEventListener('DOMContentLoaded', () => {
      initAudioButton();
      initUiBindings();
    });
    // Reinicializa se carregado tarde
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initAudioButton();
        initUiBindings();
      });
    } else {
      initAudioButton();
      initUiBindings();
    }

    // Vari√°vel para armazenar o status que est√° sendo confirmado
    let pendingStatus = null;

    // Atualiza status do ticket
    async function updateTicketStatus() {
      if (!currentTicket) return;

      const status = document.getElementById('statusSelect').value;
      const previousStatus = currentTicket.status;

      // Se vai marcar como resolvido ou encerrado, pede confirma√ß√£o (tanto para admin quanto vendedor)
      if ((status === 'resolvido' || status === 'encerrado') && previousStatus !== 'resolvido' && previousStatus !== 'encerrado') {
        pendingStatus = status;
        // Volta o select ao status anterior enquanto aguarda confirma√ß√£o
        document.getElementById('statusSelect').value = previousStatus;
        updateCustomSelect('statusSelect');

        const statusTexto = status === 'resolvido' ? 'Resolvida' : 'Encerrada';
        openConfirmModal({
          header: `‚ö†Ô∏è Marcar como ${status === 'resolvido' ? 'Resolvido' : 'Encerrado'}?`,
          message: `Tem certeza que deseja marcar esta conversa como ${statusTexto.toLowerCase()}?<br><br><strong>Ela desaparecer√° imediatamente da sua lista de atendimento.</strong>`,
          confirmText: `Sim, ${status === 'resolvido' ? 'Resolver' : 'Encerrar'}`,
          cancelText: 'Cancelar',
          onConfirm: async () => {
            if (pendingStatus) {
              await applyStatusChange(pendingStatus);
              pendingStatus = null;
            }
          },
          onCancel: () => {
            pendingStatus = null;
          }
        });
        return;
      }

      // Se for vendedor e vai marcar como 'aguardando', pede confirma√ß√£o via modal
      if (status === 'aguardando' && previousStatus !== 'aguardando') {
        pendingStatus = status;
        document.getElementById('statusSelect').value = previousStatus;
        updateCustomSelect('statusSelect');

        openConfirmModal({
          header: '‚ö†Ô∏è Marcar como Aguardando?',
          message: 'Tem certeza que deseja marcar esta conversa como <strong>Aguardando</strong>?\n\nEla ficar√° vis√≠vel para todos os vendedores e ser√° removida da atribui√ß√£o atual.',
          confirmText: 'Sim, Aguardar',
          cancelText: 'Cancelar',
          onConfirm: async () => {
            if (pendingStatus) {
              await applyStatusChange(pendingStatus);
              pendingStatus = null;
            }
          },
          onCancel: () => {
            pendingStatus = null;
          }
        });
        return;
      }

      // Se mudou de outro status (n√£o para resolvido/aguardando), aplica direto
      await applyStatusChange(status);
    }

    // Fun√ß√µes para lightbox de imagens
    function openLightbox(imageUrl) {
      if (event) {
        event.stopPropagation();
        event.preventDefault();
      }
      document.getElementById('lightboxImage').src = imageUrl;
      document.getElementById('imageLightbox').classList.add('active');
    }

    function closeLightbox() {
      document.getElementById('imageLightbox').classList.remove('active');
    }

    async function applyStatusChange(status) {
      try {
        const response = await fetch(`${API_URL}/tickets/${currentTicket.id}/status`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ status })
        });

        if (response.ok) {
          currentTicket.status = status;
          updateTicketStatusBadge(currentTicket);
          
          // Se marcou como resolvido ou encerrado, fecha e limpa tudo imediatamente
          if (status === 'resolvido' || status === 'encerrado') {
            // Limpar o ticket atual e fechar a conversa imediatamente
            const resolvedTicketId = currentTicket.id;
            currentTicket = null;
            document.getElementById('emptyState').style.display = 'flex';
            document.getElementById('chatArea').style.display = 'none';
            updateTicketStatusBadge(null);
            const statusEl = document.getElementById('currentStatus');
            if (statusEl) statusEl.textContent = '';
            const remindersPanel = document.getElementById('chatReminders');
            if (remindersPanel) remindersPanel.style.display = 'none';
            
            // Mostra mensagem de sucesso no estado vazio
            const emptyState = document.getElementById('emptyState');
            const originalContent = emptyState.innerHTML;
            const statusTexto = status === 'resolvido' ? 'resolvida' : 'encerrada';
            emptyState.innerHTML = `
              <div style="color: #00a884; gap: 15px; display: flex; flex-direction: column; align-items: center;">
                <div style="font-size: 48px;">‚úÖ</div>
                <p style="font-size: 16px; font-weight: 600;">Conversa ${statusTexto}!</p>
                <p style="font-size: 13px; color: #667781;">O atendimento foi finalizado</p>
              </div>
            `;
            
            // Restaura o estado vazio original ap√≥s 2 segundos
            setTimeout(() => {
              emptyState.innerHTML = originalContent;
              bindEmptyStateActions();
              loadEmptyStateReminders();
            }, 2000);

            // Recarrega a lista de tickets (sem filtrar resolvidos/encerrados)
            await loadTickets({ append: false, refreshTop: false });
          }
          // Se marcou como aguardando, limpa atribui√ß√£o localmente
          else if (status === 'aguardando') {
            currentTicket.seller_id = null;
            currentTicket.seller_name = null;
            // Atualiza o sellerSelect para 'N√£o atribu√≠do' quando existir
            const sellerSelect = document.getElementById('sellerSelect');
            if (sellerSelect) {
              sellerSelect.value = '';
              updateCustomSelect('sellerSelect');
            }
            await loadTickets({ refreshTop: true });
            await loadRemindersForTicket(currentTicket.id);
          }
          else {
            await loadTickets({ refreshTop: true });
            await loadRemindersForTicket(currentTicket.id);
          }
        }
      } catch (error) {
        document.getElementById('statusSelect').value = currentTicket.status;
        updateCustomSelect('statusSelect');
      }
    }

    // Enter para enviar
    function handleEnter(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    }

    // Volta para lista de tickets (mobile)
    function backToTicketList() {
      document.querySelector('.tickets-panel').classList.remove('hide-mobile');
    }

    function closeCurrentConversation() {
      currentTicket = null;
      document.getElementById('emptyState').style.display = 'flex';
      document.getElementById('chatArea').style.display = 'none';
      updateTicketStatusBadge(null);
      const statusEl = document.getElementById('currentStatus');
      if (statusEl) statusEl.textContent = '';
      const remindersPanel = document.getElementById('chatReminders');
      if (remindersPanel) remindersPanel.style.display = 'none';
      try { backToTicketList(); } catch (_) {}
      bindEmptyStateActions();
      loadEmptyStateReminders();
    }

    // Auto-refresh mais agressivo
    (async function init() {
      await checkAuth(); // Verifica autentica√ß√£o primeiro e aguarda
      checkConnectionStatus(); // Verifica conex√£o ao carregar
      await loadTickets(); // Agora userType j√° est√° definido
      await openTicketFromUrl();
      initTicketsInfiniteScroll();
      bindEmptyStateActions();

      if (!reminderPollTimer) {
        checkDueReminders();
        loadEmptyStateReminders();
        reminderPollTimer = setInterval(() => {
          checkDueReminders();
          loadEmptyStateReminders();
        }, 60000);
      }

      // Garante que mudan√ßas no select de status sempre acionem a fun√ß√£o
      const statusSelect = document.getElementById('statusSelect');
      if (statusSelect) {
        statusSelect.removeEventListener('change', updateTicketStatus);
        statusSelect.addEventListener('change', updateTicketStatus);
      }
      
      // Adaptive polling: use timeouts so we can vary the delay when tab not focused
      // Em escala, polling agressivo derruba o backend (muitos agentes = muitas requisi√ß√µes).
      // Estes valores ainda d√£o sensa√ß√£o de tempo real, mas com bem menos carga.
      const POLL_TICKETS_ACTIVE = 4500; // ms when focused
      const POLL_TICKETS_INACTIVE = 20000; // ms when not focused
      const POLL_MESSAGES_ACTIVE = 2500; // ms when focused
      const POLL_MESSAGES_INACTIVE = 12000;

      // Leader election per browser (reduz carga quando vendedor abre m√∫ltiplas abas)
      const TAB_ID = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
      const LEADER_KEY = 'ws-system:poll-leader:v1';
      const LEADER_TTL_MS = 9000;
      const HEARTBEAT_MS = 2500;

      function readLeader() {
        try { return JSON.parse(localStorage.getItem(LEADER_KEY) || 'null'); } catch (_) { return null; }
      }

      function writeLeader(obj) {
        try { localStorage.setItem(LEADER_KEY, JSON.stringify(obj)); } catch (_) {}
      }

      function isLeader() {
        const l = readLeader();
        if (!l || !l.id || !l.ts) return false;
        if ((Date.now() - l.ts) > LEADER_TTL_MS) return false;
        return l.id === TAB_ID;
      }

      function heartbeatLeader() {
        const l = readLeader();
        const stale = !l || !l.ts || (Date.now() - l.ts) > LEADER_TTL_MS;
        if (stale || (l && l.id === TAB_ID)) {
          writeLeader({ id: TAB_ID, ts: Date.now() });
        }
      }

      setInterval(heartbeatLeader, HEARTBEAT_MS);
      heartbeatLeader();

      let ticketsPollId = null;
      let messagesPollId = null;

      function scheduleTicketsPoll(delay) {
        if (ticketsPollId) clearTimeout(ticketsPollId);
        ticketsPollId = setTimeout(async () => {
          try {
            checkConnectionStatus();
            // Atualiza topo (primeira p√°gina) para pegar tickets novos/atualizados sem re-render total
            await loadTickets({ append: false, refreshTop: true });
          } catch (e) {}
          const base = (document.hidden || !document.hasFocus()) ? POLL_TICKETS_INACTIVE : POLL_TICKETS_ACTIVE;
          const multiTabPenalty = isLeader() ? 0 : 9000;
          const jitter = Math.floor(Math.random() * 400);
          scheduleTicketsPoll(base + multiTabPenalty + jitter);
        }, delay);
      }

      function scheduleMessagesPoll(delay) {
        if (messagesPollId) clearTimeout(messagesPollId);
        messagesPollId = setTimeout(async () => {
          try {
            if (isSelectingTicket) {
              scheduleMessagesPoll(650);
              return;
            }
            if (currentTicket && hasLoadedMessages[currentTicket.id]) {
              await loadMessages(currentTicket.id, true);
            }
          } catch (e) {}
          const base = (document.hidden || !document.hasFocus()) ? POLL_MESSAGES_INACTIVE : POLL_MESSAGES_ACTIVE;
          const multiTabPenalty = isLeader() ? 0 : 9000;
          const jitter = Math.floor(Math.random() * 350);
          scheduleMessagesPoll(base + multiTabPenalty + jitter);
        }, delay);
      }

      // start adaptive loops (primeira tentativa com delay menor para resposta r√°pida)
      scheduleTicketsPoll(1000); // Inicia com 1s
      scheduleMessagesPoll(800); // Primeira vez um pouco mais r√°pida

      // Se o usu√°rio voltar para a aba, d√° um refresh r√°pido (mas sem tempestade)
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          scheduleTicketsPoll(650 + Math.floor(Math.random() * 250));
          scheduleMessagesPoll(650 + Math.floor(Math.random() * 250));
        }
      });

      // Realtime: SSE para mensagens/tickets (mant√©m polling como fallback)
      let sse = null;
      let sseReconnectTimer = null;
      let sseRetry = 0;
      let lastRealtimeRefreshAt = 0;

      function realtimeRefreshTickets() {
        const now = Date.now();
        if (now - lastRealtimeRefreshAt < 350) return;
        lastRealtimeRefreshAt = now;
        loadTickets({ append: false, refreshTop: true });
      }

      function handleRealtimeMessage(payload) {
        if (!payload || !payload.ticketId) return;
        realtimeRefreshTickets();
        if (currentTicket && String(currentTicket.id) === String(payload.ticketId)) {
          loadMessages(currentTicket.id, true);
        }
      }

      function handleRealtimeTicket(payload) {
        if (!payload || !payload.ticketId) return;
        realtimeRefreshTickets();
      }

      function connectSse() {
        try { if (sse) sse.close(); } catch (_) {}
        sse = null;

        const source = new EventSource('/events', { withCredentials: true });
        sse = source;

        source.addEventListener('message', (ev) => {
          try { handleRealtimeMessage(JSON.parse(ev.data || '{}')); } catch (_) {}
        });
        source.addEventListener('ticket', (ev) => {
          try { handleRealtimeTicket(JSON.parse(ev.data || '{}')); } catch (_) {}
        });
        source.addEventListener('ready', () => {
          sseRetry = 0;
        });

        source.onerror = () => {
          try { source.close(); } catch (_) {}
          sse = null;
          const delay = Math.min(15000, 1000 * Math.pow(2, sseRetry++));
          if (sseReconnectTimer) clearTimeout(sseReconnectTimer);
          sseReconnectTimer = setTimeout(connectSse, delay);
        };
      }

      connectSse();
    })();

    // Use shared showNotification (ui.js). Provide fallback if missing.
    function showToast(message, type = 'success') {
      if (typeof showNotification === 'function') {
        const mapped = type === 'success' ? 'info' : type;
        showNotification(message, mapped);
        return;
      }

      // Fallback minimal toast
      const toast = document.createElement('div');
      toast.className = `custom-toast ${type}`;
      const icon = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚úÖ';
      toast.innerHTML = `
        <div class="custom-toast-icon">${icon}</div>
        <div class="custom-toast-message">${message}</div>
        <button class="custom-toast-close" data-role="close-toast">√ó</button>
      `;
      document.body.appendChild(toast);
      setTimeout(() => { toast.classList.add('hiding'); setTimeout(() => toast.remove(), 300); }, 4000);
    }

    function escapeHtml(value) {
      return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function openConfirmModal({ header, message, confirmText = 'Confirmar', cancelText = 'Cancelar', onConfirm, onCancel }) {
      const modal = document.getElementById('confirmModal');
      const headerEl = document.getElementById('confirmModalHeader');
      const messageEl = document.getElementById('confirmModalMessage');
      const confirmBtn = document.getElementById('confirmModalConfirm');
      const cancelBtn = document.getElementById('confirmModalCancel');

      headerEl.textContent = header;
      messageEl.innerHTML = message;
      confirmBtn.textContent = confirmText;
      cancelBtn.textContent = cancelText;

      const cleanup = () => {
        confirmBtn.onclick = null;
        cancelBtn.onclick = null;
      };

      confirmBtn.onclick = () => {
        modal.classList.remove('active');
        cleanup();
        if (onConfirm) onConfirm();
      };

      cancelBtn.onclick = () => {
        modal.classList.remove('active');
        cleanup();
        if (onCancel) onCancel();
      };

      modal.classList.add('active');
    }

    function confirmWithModal(options) {
      return new Promise((resolve) => {
        openConfirmModal({
          ...options,
          onConfirm: () => {
            options.onConfirm && options.onConfirm();
            resolve(true);
          },
          onCancel: () => {
            options.onCancel && options.onCancel();
            resolve(false);
          }
        });
      });
    }

    // Inicializar selects customizados
    function initCustomSelects() {
      // Status Select
      const statusSelect = document.getElementById('statusSelect');
      if (statusSelect && !statusSelect.nextElementSibling?.classList.contains('custom-select')) {
        createCustomSelect(statusSelect, 'statusSelect');
      }
      
      // Seller Select
      const sellerSelect = document.getElementById('sellerSelect');
      if (sellerSelect && !sellerSelect.nextElementSibling?.classList.contains('custom-select')) {
        createCustomSelect(sellerSelect, 'sellerSelect');
      }
    }

    function createCustomSelect(selectElement, id) {
      const wrapper = document.createElement('div');
      wrapper.className = 'custom-select';
      wrapper.dataset.selectId = id;
      
      const trigger = document.createElement('div');
      trigger.className = 'custom-select-trigger';
      trigger.textContent = selectElement.options[selectElement.selectedIndex].text;
      
      const optionsContainer = document.createElement('div');
      optionsContainer.className = 'custom-select-options';
      
      Array.from(selectElement.options).forEach((option, index) => {
        // Se for o select de status e o ticket atual n√£o estiver em 'pendente', n√£o adiciona a op√ß√£o 'pendente'
        if (id === 'statusSelect' && option.value === 'pendente' && typeof currentTicket !== 'undefined' && currentTicket && currentTicket.status !== 'pendente') {
          return;
        }
        const optionDiv = document.createElement('div');
        optionDiv.className = 'custom-select-option';
        if (option.selected) optionDiv.classList.add('selected');
        optionDiv.textContent = option.text;
        optionDiv.dataset.value = option.value;
        optionDiv.dataset.index = index;
        
        optionDiv.onclick = () => {
          selectElement.selectedIndex = index;
          trigger.textContent = option.text;
          
          // Remove selected de todos
          optionsContainer.querySelectorAll('.custom-select-option').forEach(o => {
            o.classList.remove('selected');
          });
          optionDiv.classList.add('selected');
          
          wrapper.classList.remove('open');
          
          // Dispara o evento change
          selectElement.dispatchEvent(new Event('change'));
        };
        
        optionsContainer.appendChild(optionDiv);
      });
      
      trigger.onclick = (e) => {
        e.stopPropagation();
        
        // Fecha outros selects abertos
        document.querySelectorAll('.custom-select.open').forEach(s => {
          if (s !== wrapper) s.classList.remove('open');
        });
        
        wrapper.classList.toggle('open');
      };
      
      wrapper.appendChild(trigger);
      wrapper.appendChild(optionsContainer);
      
      selectElement.parentNode.insertBefore(wrapper, selectElement.nextSibling);
    }

    // Fecha selects ao clicar fora
    document.addEventListener('click', () => {
      document.querySelectorAll('.custom-select.open').forEach(s => {
        s.classList.remove('open');
      });
    });

    // Atualiza os selects customizados quando necess√°rio
    function updateCustomSelect(selectId) {
      const selectElement = document.getElementById(selectId);
      const wrapper = document.querySelector(`[data-select-id="${selectId}"]`);
      
      if (selectElement && wrapper) {
        const trigger = wrapper.querySelector('.custom-select-trigger');
        trigger.textContent = selectElement.options[selectElement.selectedIndex].text;

        const optionsContainer = wrapper.querySelector('.custom-select-options');
        optionsContainer.querySelectorAll('.custom-select-option').forEach((optionDiv) => {
          const optIndex = parseInt(optionDiv.dataset.index, 10);
          if (!Number.isNaN(optIndex) && optIndex === selectElement.selectedIndex) {
            optionDiv.classList.add('selected');
          } else {
            optionDiv.classList.remove('selected');
          }
        });
      }
    }

    function initAudioPlayers(container) {
      if (!container) return;
      const audios = container.querySelectorAll('audio[id^="audio-"]');
      audios.forEach((audio) => {
        if (audio.dataset.inited) return;
        audio.dataset.inited = '1';

        audio.addEventListener('loadedmetadata', () => setAudioDuration(audio.id));
        audio.addEventListener('canplay', () => setAudioDuration(audio.id));
        audio.addEventListener('timeupdate', () => updateProgress(audio.id));
        audio.addEventListener('ended', () => {
          const btn = document.getElementById(`btn-${audio.id}`);
          if (btn) btn.textContent = '‚ñ∂';
          const progress = document.getElementById(`progress-${audio.id}`);
          if (progress) progress.style.width = '0%';
        });

        // Se j√° tem fonte, tenta carregar imediatamente
        const src = audio.dataset.src;
        if (src && !audio.querySelector('source')) {
          loadAudioSources(audio.id);
        }

        // Verifica dura√ß√£o se j√° carregou
        if (audio.readyState >= 1 && audio.duration > 0) {
          setAudioDuration(audio.id);
        }
      });
    }

    function setAudioDuration(audioId) {
      const audio = document.getElementById(audioId);
      const durationEl = document.getElementById(`duration-${audioId}`);
      const currentEl = document.getElementById(`current-${audioId}`);
      if (!audio || !durationEl || !currentEl) return;
      
      // Se a dura√ß√£o est√° dispon√≠vel, mostra
      if (Number.isFinite(audio.duration) && audio.duration > 0) {
        durationEl.textContent = formatTime(audio.duration);
        if (!audio.currentTime || audio.currentTime <= 0) {
          currentEl.textContent = '0:00';
        }
        return;
      }

      // Se n√£o est√° dispon√≠vel ainda e n√£o tem retry pendente, agenda um
      if (!audio.dataset.durationRetrying) {
        audio.dataset.durationRetrying = '1';
        setTimeout(() => {
          delete audio.dataset.durationRetrying;
          setAudioDuration(audioId);
        }, 300);
      }
    }

    // Audio player controls
    function toggleAudio(audioId) {
      const audio = document.getElementById(audioId);
      const btn = document.getElementById(`btn-${audioId}`);
      if (!audio || !btn) return;

      if (audio.paused) {
        ensureAudioSource(audioId);
        // Pause all other audios
        document.querySelectorAll('audio').forEach(a => {
          if (a.id !== audioId && !a.paused) {
            a.pause();
            const otherBtn = document.getElementById(`btn-${a.id}`);
            if (otherBtn) otherBtn.textContent = '‚ñ∂';
          }
        });
        
        const playPromise = audio.play();
        if (playPromise && typeof playPromise.catch === 'function') {
          playPromise.catch(() => {
            btn.textContent = '‚ñ∂';
          });
        }
        btn.textContent = '‚è∏';
      } else {
        audio.pause();
        btn.textContent = '‚ñ∂';
      }
    }

    function updateProgress(audioId) {
      const audio = document.getElementById(audioId);
      const progress = document.getElementById(`progress-${audioId}`);
      const current = document.getElementById(`current-${audioId}`);
      
      if (!audio || !progress || !current) return;
      if (!Number.isFinite(audio.duration) || audio.duration <= 0) return;
      
      const percent = Math.min(100, (audio.currentTime / audio.duration) * 100);
      progress.style.width = percent + '%';
      current.textContent = formatTime(audio.currentTime);
    }

    function seekAudio(event, audioId) {
      const audio = document.getElementById(audioId);
      const progressContainer = event.currentTarget;
      
      if (!audio || !progressContainer) return;
      if (!Number.isFinite(audio.duration) || audio.duration <= 0) return;
      
      const rect = progressContainer.getBoundingClientRect();
      const percent = (event.clientX - rect.left) / rect.width;
      audio.currentTime = Math.max(0, Math.min(audio.duration, percent * audio.duration));
    }

    function loadAudioSources(audioId) {
      const audio = document.getElementById(audioId);
      if (!audio) return;
      if (audio.querySelector('source')) return; // J√° tem fontes

      const src = audio.dataset.src;
      if (!src) return;

      // Cria sources para m√°xima compatibilidade
      const sourceOgg = document.createElement('source');
      sourceOgg.src = src;
      sourceOgg.type = 'audio/ogg';

      const sourceWebm = document.createElement('source');
      sourceWebm.src = src;
      sourceWebm.type = 'audio/webm';

      const sourceMp3 = document.createElement('source');
      sourceMp3.src = src;
      sourceMp3.type = 'audio/mpeg';

      audio.appendChild(sourceOgg);
      audio.appendChild(sourceWebm);
      audio.appendChild(sourceMp3);

      try { audio.load(); } catch (e) {}
    }

    function ensureAudioSource(audioId) {
      const audio = document.getElementById(audioId);
      if (!audio) return;

      // Se n√£o tem sources, carrega agora
      if (!audio.querySelector('source')) {
        loadAudioSources(audioId);
      }

      // Aguarda dura√ß√£o estar dispon√≠vel
      const trySetDuration = () => {
        if (audio.readyState >= 2 && audio.duration > 0) {
          setAudioDuration(audioId);
        } else {
          // Tenta novamente em pouco tempo
          setTimeout(() => trySetDuration(), 100);
        }
      };
      trySetDuration();
    }

    function formatTime(seconds) {
      if (!Number.isFinite(seconds) || seconds < 0) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return mins + ':' + (secs < 10 ? '0' : '') + secs;
    }

    // Variables para gerenciar reply
    let currentReplyTo = null;
    let currentReplyData = null;

    // Fun√ß√£o para definir mensagem a ser respondida
    async function setReplyTo(messageId) {
      try {
        const response = await fetch(`${API_URL}/messages/${messageId}`, {
          credentials: 'include'
        });

        if (!response.ok) {
          showToast('Erro ao carregar mensagem original', 'error');
          return;
        }

        currentReplyData = await response.json();
        currentReplyTo = messageId;
        displayReplyPreview();
        await ensureAdminAssignmentOnReply();
      } catch (error) {
        console.error('Erro ao buscar mensagem:', error);
        showToast('Erro ao carregar mensagem original', 'error');
      }
    }

    async function ensureAdminAssignmentOnReply() {
      if (!currentTicket || userType !== 'admin') return;
      const alreadyAssignedToAdmin = currentTicket.seller_name && userName && currentTicket.seller_name === userName;
      if (alreadyAssignedToAdmin) return;
      try {
        await applyStatusChange('em_atendimento');
      } catch (_e) {}
    }

    // Fun√ß√£o para exibir preview da resposta
    function displayReplyPreview() {
      if (!currentReplyData) return;

      const preview = document.getElementById('replyPreview');
      const content = document.getElementById('replyPreviewContent');

      if (!preview || !content) return;

      // Prepara o texto da mensagem original
      let originalText = currentReplyData.content || '';
      if (currentReplyData.message_type === 'image') {
        originalText = 'üñºÔ∏è Imagem';
      } else if (currentReplyData.message_type === 'audio') {
        originalText = 'üé§ √Åudio';
      } else if (currentReplyData.message_type === 'video') {
        originalText = 'üé• V√≠deo';
      } else if (currentReplyData.message_type === 'sticker') {
        originalText = '‚ú® Figurinha';
      }

      content.textContent = `${currentReplyData.sender_name || 'Usu√°rio'}: ${originalText}`;
      preview.classList.add('active');
    }

    // Fun√ß√£o para limpar resposta
    function clearReply() {
      currentReplyTo = null;
      currentReplyData = null;
      const preview = document.getElementById('replyPreview');
      if (preview) {
        preview.classList.remove('active');
      }
    }

    // Fun√ß√£o para gerar quote block HTML
    function generateQuoteBlock(message) {
      if (!message.reply_to_id) return '';

      // Nota: Voc√™ precisa buscar os dados da mensagem original
      // Por enquanto, retorna um placeholder que ser√° preenchido via JS
      return `
        <div class="message-quote" data-reply-id="${message.reply_to_id}">
          <div class="message-quote-author" id="quote-author-${message.reply_to_id}">Carregando...</div>
          <div class="message-quote-content" id="quote-content-${message.reply_to_id}">...</div>
        </div>
      `;
    }

    // Fun√ß√£o para carregar e exibir dados da mensagem citada
    async function loadQuoteData(replyId) {
      try {
        const response = await fetch(`${API_URL}/messages/${replyId}`, {
          credentials: 'include'
        });

        if (!response.ok) return;

        const originalMsg = await response.json();
        const authorEl = document.getElementById(`quote-author-${replyId}`);
        const contentEl = document.getElementById(`quote-content-${replyId}`);

        if (!authorEl || !contentEl) return;

        let contentText = originalMsg.content || '';
        if (originalMsg.message_type === 'image') {
          contentText = 'üñºÔ∏è Imagem';
        } else if (originalMsg.message_type === 'audio') {
          contentText = 'üé§ √Åudio';
        } else if (originalMsg.message_type === 'video') {
          contentText = 'üé• V√≠deo';
        } else if (originalMsg.message_type === 'sticker') {
          contentText = '‚ú® Figurinha';
        }

        authorEl.textContent = `${originalMsg.sender_name || 'Usu√°rio'}:`;
        contentEl.textContent = contentText;
      } catch (error) {
        console.error('Erro ao carregar mensagem citada:', error);
      }
    }

    // Sistema avan√ßado de clique-duplo vs clique-simples para m√≠dias
    // Rastreia cliques pendentes para detectar duplo clique
    const clickTimers = new Map();
    const DOUBLE_CLICK_DELAY = 300; // ms

    function handleMediaClick(event, mediaType, messageId) {
      event.stopPropagation();
      
      const mediaElement = mediaType === 'audio'
        ? event.target.closest('.audio-play-btn')
        : event.target;
      if (!mediaElement) return;
      const clickKey = `${messageId}-${mediaType}`;
      
      // Se j√° h√° um clique pendente, √© um duplo clique
      if (clickTimers.has(clickKey)) {
        clearTimeout(clickTimers.get(clickKey));
        clickTimers.delete(clickKey);
        
        // DUPLO CLIQUE: Ativa o reply
        const msgElement = mediaElement.closest('.message');
        if (msgElement) {
          const msgId = msgElement.id.replace('msg-', '');
          if (msgId) {
            setReplyTo(msgId);
            // Adiciona feedback visual
            msgElement.style.backgroundColor = 'rgba(0, 168, 132, 0.1)';
            setTimeout(() => {
              msgElement.style.backgroundColor = '';
            }, 300);
          }
        }
      } else {
        // CLIQUE SIMPLES: Abre a m√≠dia
        const timer = setTimeout(() => {
          clickTimers.delete(clickKey);
          
          if (mediaType === 'image' || mediaType === 'sticker') {
            // Abre lightbox para imagens
            openLightbox(mediaElement.src || mediaElement.dataset.src);
          } else if (mediaType === 'video') {
            // Para v√≠deos, toggle play/pause
            if (mediaElement.paused) {
              mediaElement.play();
            } else {
              mediaElement.pause();
            }
          } else if (mediaType === 'audio') {
            // Para √°udio, ativa o player
            const audioId = mediaElement.dataset?.audioId || (mediaElement.id ? mediaElement.id.replace('btn-', '') : null);
            if (audioId) toggleAudio(audioId);
          }
        }, DOUBLE_CLICK_DELAY);
        
        clickTimers.set(clickKey, timer);
      }
    }

    // Inicializa listeners de clique e duplo clique nas mensagens
    function initMessageReplyListeners(container) {
      if (!container) return;
      if (container.dataset.replyListenersInit === '1') return;
      container.dataset.replyListenersInit = '1';

      // Delega√ß√£o de eventos para clique simples em m√≠dias
      container.addEventListener('click', (e) => {
        const msgElement = e.target.closest('.message');
        if (!msgElement) return;

        // Verifica se foi clique em imagem
        const imgElement = e.target.closest('.message-image');
        if (imgElement && imgElement.classList.contains('message-image')) {
          const msgId = msgElement.id.replace('msg-', '');
          handleMediaClick(e, 'image', msgId);
          return;
        }

        // Verifica se foi clique em v√≠deo
        const videoElement = e.target.closest('video');
        if (videoElement && videoElement.classList.contains('lazy-media')) {
          // Verifica se o clique foi nos controles do v√≠deo
          const rect = videoElement.getBoundingClientRect();
          const clickY = e.clientY - rect.top;
          const controlsHeight = 40; // Altura aproximada dos controles
          
          // Se clique foi na √°rea de controles, deixa os controles nativos funcionarem
          if (clickY > rect.height - controlsHeight) {
            return;
          }
          
          const msgId = msgElement.id.replace('msg-', '');
          handleMediaClick(e, 'video', msgId);
          return;
        }

        // Verifica se foi clique em figurinha
        const stickerElement = e.target.closest('.message-sticker');
        if (stickerElement && stickerElement.classList.contains('message-sticker')) {
          const msgId = msgElement.id.replace('msg-', '');
          handleMediaClick(e, 'sticker', msgId);
          return;
        }

        // Verifica se foi clique em √°udio
        const audioPlayBtn = e.target.closest('.audio-play-btn');
        if (audioPlayBtn) {
          const msgId = msgElement.id.replace('msg-', '');
          handleMediaClick(e, 'audio', msgId);
          return;
        }

        // Clique simples em texto: nenhuma a√ß√£o (pode ser clique em reply)
      });

      // Duplo clique em qualquer elemento da mensagem ativa reply
      container.addEventListener('dblclick', (e) => {
        // Ignora duplo clique se for nos controles de m√≠dia
        if (e.target.closest('.audio-play-btn') || 
            e.target.closest('.audio-progress')) {
          return;
        }

        const msgElement = e.target.closest('.message');
        if (!msgElement) return;

        const msgId = msgElement.id.replace('msg-', '');
        if (msgId) {
          setReplyTo(msgId);
          // Feedback visual
          msgElement.style.backgroundColor = 'rgba(0, 168, 132, 0.1)';
          setTimeout(() => {
            msgElement.style.backgroundColor = '';
          }, 300);
        }
      });

      // Suporte a touch para mobile (duplo toque)
      const touchTimers = new Map();
      const TOUCH_DELAY = 300; // ms

      container.addEventListener('touchend', (e) => {
        const msgElement = e.target.closest('.message');
        if (!msgElement) return;

        const msgId = msgElement.id.replace('msg-', '');
        const touchKey = `touch-${msgId}`;

        // Se j√° h√° um toque pendente, √© um duplo toque
        if (touchTimers.has(touchKey)) {
          clearTimeout(touchTimers.get(touchKey));
          touchTimers.delete(touchKey);

          // DUPLO TOQUE: Ativa o reply
          if (msgId) {
            setReplyTo(msgId);
            // Feedback visual
            msgElement.style.backgroundColor = 'rgba(0, 168, 132, 0.1)';
            setTimeout(() => {
              msgElement.style.backgroundColor = '';
            }, 300);
          }
        } else {
          // TOQUE SIMPLES: Verifica se √© em m√≠dia
          const touchTarget = e.target;
          
          // Toque em imagem
          if (touchTarget.closest('.message-image')) {
            const timer = setTimeout(() => {
              touchTimers.delete(touchKey);
              openLightbox(touchTarget.src || touchTarget.dataset.src);
            }, TOUCH_DELAY);
            touchTimers.set(touchKey, timer);
            return;
          }

          // Toque em figurinha
          if (touchTarget.closest('.message-sticker')) {
            const timer = setTimeout(() => {
              touchTimers.delete(touchKey);
              openLightbox(touchTarget.src || touchTarget.dataset.src);
            }, TOUCH_DELAY);
            touchTimers.set(touchKey, timer);
            return;
          }

          // Toque em v√≠deo
          if (touchTarget.closest('video')) {
            const videoElement = touchTarget.closest('video');
            const timer = setTimeout(() => {
              touchTimers.delete(touchKey);
              // Toque simples em v√≠deo: play/pause
              if (videoElement.paused) {
                videoElement.play();
              } else {
                videoElement.pause();
              }
            }, TOUCH_DELAY);
            touchTimers.set(touchKey, timer);
            return;
          }

          // Para outros casos, aguarda para ver se √© duplo toque
          const timer = setTimeout(() => {
            touchTimers.delete(touchKey);
          }, TOUCH_DELAY);
          touchTimers.set(touchKey, timer);
        }
      });
    }
  </script>
</body>
</html>
